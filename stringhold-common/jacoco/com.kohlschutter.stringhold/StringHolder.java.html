<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringHolder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stringhold-common</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolder.java</span></div><h1>StringHolder.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Objects;
import java.util.function.Supplier;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;
import com.kohlschutter.util.ComparisonUtil;

/**
 * A {@link StringHolder} holds something that can &lt;em&gt;eventually&lt;/em&gt; turn into a string.
 *
 * {@link StringHolder}s may reduce string allocation in cases where the final string sequence is,
 * for example sent to a Writer (or other Appendable), discarded after a certain length, ignored
 * upon an exception thrown along the way, etc.
 *
 * Apart from reducing string concatenation-related allocations, {@link StringHolder}s may reduce
 * the end-to-end string life-cycle by allowing concurrency between construction and transmission:
 * The string can be transmitted while it's being constructed.
 *
 * Unlike regular stream-based approaches, a pre-rendered structure is available before transmission
 * starts. This means a transmission that is known to exceed certain limits can be stopped before a
 * single character is transmitted.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings({
    &quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveClassLength&quot;, &quot;PMD.ExcessivePublicCount&quot;})
public abstract class StringHolder extends CharSequenceReleaseShim implements CharSequence,
    HasLength, Comparable&lt;Object&gt; {
  String theString;

  private int minLength;
  private int expectedLength;

<span class="fc" id="L57">  private boolean trouble = false;</span>

<span class="fc" id="L59">  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)</span>
  private StringHolderScope scope = null;

  /**
   * Constructs a {@link StringHolder} with a zero minimum length.
   */
  protected StringHolder() {
<span class="fc" id="L66">    this(0);</span>
<span class="fc" id="L67">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length, use {@code 0} if no minimum
   * length is known.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   */
  protected StringHolder(int minLength) {
<span class="fc" id="L76">    this(minLength, minLength);</span>
<span class="fc" id="L77">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length (use {@code 0} if no minimum
   * length is known), and expected length.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   * @param expectedLength The expected length, which may be larger than the eventual actual length
   */
  protected StringHolder(int minLength, int expectedLength) {
<span class="fc" id="L87">    super();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (minLength &lt; 0) {</span>
<span class="fc" id="L89">      throw new IllegalArgumentException(&quot;Invalid minLength&quot;);</span>
    }
<span class="fc" id="L91">    this.minLength = minLength;</span>
<span class="fc" id="L92">    this.expectedLength = Math.max(minLength, expectedLength);</span>
<span class="fc" id="L93">  }</span>

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(Supplier&lt;?&gt; supplier) {
<span class="fc" id="L105">    return withSupplierMinimumLength(0, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L120">    return withSupplierMinimumLength(0, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L134">    return new SuppliedStringHolder(minLength, minLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L151">    return new SuppliedStringHolder(minLength, minLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L165">    return new SuppliedStringHolder(0, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L182">    return new SuppliedStringHolder(0, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      Supplier&lt;?&gt; supplier) {
<span class="fc" id="L198">    return new SuppliedStringHolder(minLength, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L216">    return new SuppliedStringHolder(minLength, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, Supplier&lt;?&gt; supplier) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L232">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L234">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L253">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L255">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplier(IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L268">    return new ReaderStringHolder(0, 0, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumLength(int minLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L282">    return new ReaderStringHolder(minLen, minLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierExpectedLength(int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L296">    return new ReaderStringHolder(0, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumAndExpectedLength(int minLen, int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L311">    return new ReaderStringHolder(minLen, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link StringHolder} with the given content.
   *
   * Unless the object already is a {@link StringHolder}, or is known to be empty, its contents are
   * converted to String. {@code null} objects are converted to {@code &quot;null&quot;}, in accordance with
   * {@link String#valueOf(Object)}.
   *
   * @param obj The object.
   * @return The {@link StringHolder} instance.
   */
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  public static StringHolder withContent(Object obj) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L327">      return CommonStrings.NULL_STRINGHOLDER;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L329">      String s = (String) obj;</span>
<span class="fc" id="L330">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L332">        return sh;</span>
      }
<span class="fc" id="L334">      return new SimpleStringHolder(s);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L336">      return (StringHolder) obj;</span>
    } else {
<span class="fc bfc" id="L338" title="All 2 branches covered.">      if (obj instanceof CharSequence) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (CharSequenceReleaseShim.isEmpty((CharSequence) obj)) {</span>
<span class="fc" id="L340">          return CommonStrings.EMPTY_STRINGHOLDER;</span>
        }
      } else {
<span class="fc" id="L343">        StringHolder sh = CommonStrings.lookup(obj);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (sh != null) {</span>
<span class="fc" id="L345">          return sh;</span>
        }
      }
<span class="fc" id="L348">      String s = String.valueOf(obj);</span>
<span class="fc" id="L349">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L351">        return sh;</span>
      }
<span class="fc" id="L353">      return new SimpleStringHolder(s);</span>
    }
  }

  /**
   * Constructs a {@link StringHolder} with the given content sequences, as if they had been
   * appended to a {@link StringHolderSequence}. Empty sequences are optimized.
   *
   * @param objects The objects to represent as a sequence; if {@code null}, a StringHolder of the
   *          string {@code &quot;null&quot;} is returned.
   * @return The {@link StringHolder} instance.
   * @see #withContent(Object)
   */
  public static StringHolder withContent(Object... objects) {
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (objects == null) {</span>
<span class="fc" id="L368">      return CommonStrings.NULL_STRINGHOLDER;</span>
    }
<span class="fc bfc" id="L370" title="All 3 branches covered.">    switch (objects.length) {</span>
      case 0:
<span class="fc" id="L372">        return CommonStrings.EMPTY_STRINGHOLDER;</span>
      case 1:
<span class="fc" id="L374">        return withContent(objects[0]);</span>
      default:
        // see below
    }
<span class="fc" id="L378">    StringHolderSequence seq = new StringHolderSequence(objects.length);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">    for (Object obj : objects) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (obj instanceof StringHolder //</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">          &amp;&amp; ((StringHolder) obj).isKnownEmpty()) {</span>
<span class="fc" id="L382">        continue;</span>
<span class="fc bfc" id="L383" title="All 4 branches covered.">      } else if (obj instanceof CharSequence &amp;&amp; CharSequenceReleaseShim.isEmpty(</span>
          (CharSequence) obj)) {
<span class="fc" id="L385">        continue;</span>
      }
<span class="fc" id="L387">      seq.append(obj);</span>
    }
<span class="fc bfc" id="L389" title="All 2 branches covered.">    if (seq.numberOfAppends() == 0) {</span>
<span class="fc" id="L390">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    } else {
<span class="fc" id="L392">      return seq;</span>
    }
  }

  /**
   * Returns the current minimum length of the expected string length in this {@link StringHolder}.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * NOTE: When using this parameter for optimizations (e.g., to speed-up equality checks), make
   * sure to also check {@link #checkError()}. When that method returns {@code true}, the minimum
   * length can actually not be guaranteed.
   *
   * @return The minimum length (but be sure to see {@link #checkError()}).
   */
  @Override
  public final int getMinimumLength() {
<span class="fc" id="L409">    return minLength;</span>
  }

  /**
   * Returns the current estimate of the length of the string in this {@link StringHolder}, which is
   * at least the {@link #getMinimumLength()} but could be substantially larger.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * @return The currently expected length.
   */
  @Override
  public final int getExpectedLength() {
<span class="fc" id="L422">    return expectedLength;</span>
  }

  /**
   * Updates the current estimate of the length of the string in this {@link StringHolder}.
   *
   * The value will be rounded to {@link #getMinimumLength()} if necessary.
   *
   * @param len The new expected length
   */
  public void setExpectedLength(int len) {
<span class="fc" id="L433">    resizeTo(getMinimumLength(), len);</span>
<span class="fc" id="L434">  }</span>

  /**
   * Sets the expected lengths (minimum and estimated) to the given values.
   *
   * @param min The new minimum length, must not be smaller than the current minimum (unless
   *          {@link #checkError()} is {@code true})
   * @param expected The new expected length (will be rounded up if less than {@code min}).
   * @return The new expected length (which may be adjusted to the new minimum).
   * @throws IllegalStateException if the value is negative, and {@link #checkError()} is
   *           {@code false}.
   */
  protected final int resizeTo(int min, int expected) {
<span class="fc" id="L447">    return resizeTo(min, expected, false);</span>
  }

  private int resizeTo(int min, int expected, boolean fromToString) {
<span class="fc" id="L451">    int oldMin = this.minLength;</span>
<span class="fc" id="L452">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L454" title="All 4 branches covered.">    if (!fromToString &amp;&amp; isString()) {</span>
      // unchanged
<span class="fc" id="L456">      return oldExpected;</span>
    }

<span class="fc bfc" id="L459" title="All 2 branches covered.">    if (min &lt; oldMin) {</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">      if (checkError()) {</span>
        // throw away our previous expectations upon error
<span class="fc" id="L462">        expected = (min = Math.max(0, min));</span>
      } else {
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (fromToString) {</span>
<span class="fc" id="L465">          setError();</span>
<span class="fc" id="L466">          resizeTo(min, expected, false);</span>
<span class="fc" id="L467">          throw new IllegalStateException(&quot;Detected mispredicted minLength&quot;);</span>
        } else {
<span class="fc" id="L469">          throw new IllegalStateException(&quot;New minimum is smaller than current minimum&quot;);</span>
        }
      }
    }

<span class="fc" id="L474">    int el = (this.expectedLength = Math.max((this.minLength = min), expected));</span>

<span class="fc" id="L476">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L479">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L480">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L481">        setError();</span>
<span class="fc" id="L482">        throw e;</span>
<span class="fc" id="L483">      }</span>
    }

<span class="fc" id="L486">    return el;</span>
  }

  /**
   * Increases the expected lengths (minimum and estimated) by the given values.
   *
   * Any value that overflows {@link Integer#MAX_VALUE} will be capped at that limit.
   *
   * @param minBy The minimum length increment, must not be negative (unless {@link #checkError()}
   *          is {@code true})
   * @param expectedBy The expected length increment, may be negative; final length will be
   *          {@code &gt;= 0}.
   * @throws IllegalArgumentException if minBy is negative and {@link #checkError()} is
   *           {@code false}
   */
  protected final void resizeBy(int minBy, int expectedBy) {
<span class="fc" id="L502">    int oldMin = this.minLength;</span>
<span class="fc" id="L503">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L505" title="All 2 branches covered.">    if (minBy &lt; 0) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">      if (checkError()) {</span>
<span class="fc" id="L507">        this.minLength = Math.max(0, this.minLength + minBy);</span>
      } else {
<span class="fc" id="L509">        throw new IllegalArgumentException(&quot;Minimum length increment is negative&quot;);</span>
      }
<span class="fc bfc" id="L511" title="All 2 branches covered.">    } else if ((this.minLength += minBy) &lt; 0) {</span>
      // cannot express minimum length that large
<span class="fc" id="L513">      this.minLength = Integer.MAX_VALUE;</span>
    }
<span class="fc" id="L515">    this.expectedLength = Math.max(minLength, this.expectedLength + expectedBy);</span>

<span class="fc" id="L517">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L520">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L521">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L522">        setError();</span>
<span class="fc" id="L523">        throw e;</span>
<span class="fc" id="L524">      }</span>
    }
<span class="fc" id="L526">  }</span>

  /**
   * Returns the actual length of this instance's contents. This may trigger a conversion to
   * {@link String}.
   *
   * @return The actual length.
   */
  @Override
  public final int length() {
<span class="fc bfc" id="L536" title="All 2 branches covered.">    if (theString != null) {</span>
<span class="fc" id="L537">      return minLength;</span>
    } else {
<span class="fc" id="L539">      return resizeTo(computeLength(), 0);</span>
    }
  }

  /**
   * Computes the actual length of this instance's contents.
   *
   * By default, this is implemented as {@code toString().length()}.
   *
   * When overriding this method, make sure to also override {@link #isLengthKnown()}.
   *
   * @return The actual length.
   */
  protected int computeLength() {
<span class="fc" id="L553">    return toString().length();</span>
  }

  /**
   * Checks if this holder is currently backed by a plain {@link String}.
   *
   * @return {@code true} if currently backed by a plain {@link String}.
   */
  public final boolean isString() {
<span class="fc bfc" id="L562" title="All 2 branches covered.">    return theString != null;</span>
  }

  /**
   * Checks if this {@link StringHolder} is known to yield an empty {@link String}.
   *
   * @return {@code true} if known non-empty.
   */
  @Override
  public final boolean isKnownEmpty() {
<span class="fc bfc" id="L572" title="All 2 branches covered.">    if (minLength &gt; 0) {</span>
<span class="fc" id="L573">      return false;</span>
<span class="fc bfc" id="L574" title="All 4 branches covered.">    } else if (isLengthKnown() &amp;&amp; length() == 0) {</span>
<span class="fc" id="L575">      return true;</span>
    } else {
      String s;

<span class="fc bfc" id="L579" title="All 4 branches covered.">      return (s = theString) != null &amp;&amp; s.isEmpty();</span>
    }
  }

  @Override
  public final boolean isEmpty() {
<span class="fc bfc" id="L585" title="All 4 branches covered.">    return isKnownEmpty() || super.isEmpty();</span>
  }

  /**
   * Returns {@code true} if the actual length is known, i.e. {@link #getMinimumLength()} {@code ==}
   * {@link #getExpectedLength()} {@code == } {@link #length()}.
   *
   * By default, this is only true if {@link #isString()} {@code == true}, but subclasses may
   * override this check. When they do, they must include a check for
   * {@code || super.isLengthKnown()}.
   *
   * Note that once a length is &lt;em&gt;known&lt;/em&gt;, it cannot change (i.e., don't override this for
   * mutable objects like {@link StringHolderSequence}).
   *
   * @return {@code true} if the length in this holder is known.
   * @see #isKnownEmpty()
   */
  @Override
  public boolean isLengthKnown() {
<span class="fc" id="L604">    return isString();</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L609">    return toString().hashCode();</span>
  }

  @SuppressFBWarnings(&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;)
  @Override
  public final boolean equals(Object obj) {
<span class="fc bfc" id="L615" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L616">      return false;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">    } else if (obj == this) {</span>
<span class="fc" id="L618">      return true;</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L620">      return equalsString((String) obj);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L622">      return equalsStringHolder((StringHolder) obj);</span>
    } else {
<span class="fc" id="L624">      return false;</span>
    }
  }

  private boolean equalsString(String s) {
<span class="fc bfc" id="L629" title="All 4 branches covered.">    if (!checkError() &amp;&amp; s.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L630">      return false;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">    } else if (isString()) {</span>
<span class="fc" id="L632">      return toString().equals(s);</span>
<span class="fc bfc" id="L633" title="All 4 branches covered.">    } else if (isLengthKnown() &amp;&amp; length() != s.length()) {</span>
<span class="fc" id="L634">      return false;</span>
    } else {
<span class="fc" id="L636">      return checkEquals(s);</span>
    }
  }

  /**
   * Checks if this {@link StringHolder} instance is equal to the given String (assume that trivial
   * requirements, such as minimum length, were already checked).
   *
   * Subclasses may override this check for a faster operation.
   *
   * @param s The other string.
   * @return {@code true} if this {@link StringHolder} is equal to the given string.
   */
  protected boolean checkEquals(String s) {
<span class="fc" id="L650">    return toString().equals(s);</span>
  }

  /**
   * Checks if this {@link StringHolder} instance is equal to the given {@link StringHolder} (assume
   * that trivial requirements, such as minimum length, were already checked).
   *
   * Subclasses may override this check for a faster operation.
   *
   * @param sh The other {@link StringHolder}.
   * @return {@code true} if this {@link StringHolder} is equal to the given string.
   */
  protected boolean checkEquals(StringHolder sh) {
<span class="fc" id="L663">    return toString().equals(sh.toString());</span>
  }

  private boolean equalsStringHolder(StringHolder obj) {
<span class="fc bfc" id="L667" title="All 6 branches covered.">    if (isLengthKnown() &amp;&amp; obj.isLengthKnown() &amp;&amp; length() != obj.length()) {</span>
<span class="fc" id="L668">      return false;</span>
    }

<span class="fc bfc" id="L671" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L672" title="All 4 branches covered.">      if (!obj.checkError() &amp;&amp; length() &lt; obj.getMinimumLength()) {</span>
<span class="fc" id="L673">        return false;</span>
      }
<span class="fc bfc" id="L675" title="All 2 branches covered.">      if (obj.isString()) {</span>
<span class="fc" id="L676">        return toString().equals(obj.toString());</span>
      } else {
<span class="fc" id="L678">        return obj.equalsString(toString());</span>
      }
<span class="fc bfc" id="L680" title="All 2 branches covered.">    } else if (obj.isString()) {</span>
<span class="fc bfc" id="L681" title="All 4 branches covered.">      if (!checkError() &amp;&amp; obj.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L682">        return false;</span>
      }
    }

<span class="fc" id="L686">    return checkEquals(obj);</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Appendable out) throws IOException {
<span class="fc" id="L697">    appendToAndReturnLength(out);</span>
<span class="fc" id="L698">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}; this may
   * or may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuilder out) {
<span class="fc" id="L707">    appendToAndReturnLength(out);</span>
<span class="fc" id="L708">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuffer out) {
<span class="fc" id="L717">    appendToAndReturnLength(out);</span>
<span class="fc" id="L718">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}; this may or may
   * not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Writer out) throws IOException {
<span class="fc" id="L728">    appendToAndReturnLength(out);</span>
<span class="fc" id="L729">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Appendable out) throws IOException {
<span class="fc bfc" id="L741" title="All 2 branches covered.">    if (out instanceof Writer) {</span>
<span class="fc" id="L742">      return appendToAndReturnLength((Writer) out);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">    } else if (out instanceof StringBuilder) {</span>
<span class="fc" id="L744">      return appendToAndReturnLength((StringBuilder) out);</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">    } else if (out instanceof StringBuffer) {</span>
<span class="fc" id="L746">      return appendToAndReturnLength((StringBuffer) out);</span>
    } else {
<span class="fc" id="L748">      return appendToAndReturnLengthDefault(out);</span>
    }
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuilder out) {
    int len;
<span class="fc bfc" id="L762" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L763">      len = length();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">      if (len &gt; 0) {</span>
<span class="fc" id="L765">        out.append(toString());</span>
      }
    } else {
<span class="fc" id="L768">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L770">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L773">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuffer out) {
    int len;
<span class="fc bfc" id="L786" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L787">      len = length();</span>
<span class="fc" id="L788">      out.append(toString());</span>
    } else {
<span class="fc" id="L790">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L792">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L795">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Writer out) throws IOException {
    int len;
<span class="fc bfc" id="L809" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L810">      len = length();</span>
<span class="fc" id="L811">      out.append(toString());</span>
    } else {
<span class="fc" id="L813">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L815">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L818">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable} (which is
   * neither a {@link StringBuilder}, {@link StringBuffer}, nor a {@link Writer}), and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @see #appendToAndReturnLength(StringBuilder)
   * @see #appendToAndReturnLength(StringBuffer)
   * @see #appendToAndReturnLength(StringWriter)
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthDefaultImpl(Appendable out) throws IOException {
<span class="fc" id="L835">    String s = toString();</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">    if (!s.isEmpty()) {</span>
<span class="fc" id="L837">      out.append(s);</span>
    }
<span class="fc" id="L839">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuilder out) {
<span class="fc" id="L851">    String s = toString();</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">    if (!s.isEmpty()) {</span>
<span class="fc" id="L853">      out.append(s);</span>
    }
<span class="fc" id="L855">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuffer out) {
<span class="fc" id="L867">    String s = toString();</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">    if (!s.isEmpty()) {</span>
<span class="fc" id="L869">      out.append(s);</span>
    }
<span class="fc" id="L871">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthImpl(Writer out) throws IOException {
    // subclasses may implement a better way for Writers, but we don't
<span class="fc" id="L885">    return appendToAndReturnLengthDefault(out);</span>
  }

  private int appendToAndReturnLengthDefault(Appendable out) throws IOException {
    int len;
<span class="fc bfc" id="L890" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L891">      len = length();</span>
<span class="fc" id="L892">      out.append(toString());</span>
    } else {
<span class="fc" id="L894">      len = appendToAndReturnLengthDefaultImpl(out);</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L896">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L899">    return len;</span>
  }

  @Override
  public final String toString() {
<span class="fc" id="L904">    String s = theString;</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L906">      return s;</span>
    }
<span class="fc" id="L908">    synchronized (this) {</span>
      try {
<span class="fc bfc" id="L910" title="All 2 branches covered.">        if (isKnownEmpty()) {</span>
<span class="fc" id="L911">          theString = s = &quot;&quot;;</span>
        } else {
<span class="fc" id="L913">          theString = s = CommonStrings.lookupIfPossible(Objects.requireNonNull(getString()));</span>
        }
<span class="fc" id="L915">        resizeTo(s.length(), 0, true);</span>
<span class="fc" id="L916">      } catch (RuntimeException e) {</span>
<span class="fc" id="L917">        s = theString;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">        if (s != null) {</span>
<span class="fc" id="L919">          resizeTo(s.length(), 0, true);</span>
        }
<span class="fc" id="L921">        setError();</span>
<span class="fc" id="L922">        throw e;</span>
<span class="fc" id="L923">      }</span>

<span class="fc" id="L925">      stringSanityCheck(s);</span>
<span class="fc" id="L926">      return s;</span>
    }
  }

  /**
   * Called from within {@link #toString()} after updating/assigning the cached string but before
   * returning it. This may be a good opportunity to see if we got what we wanted, call setError,
   * etc.
   *
   * @param s The string.
   */
  protected void stringSanityCheck(String s) {
<span class="fc" id="L938">  }</span>

  /**
   * Retrieves the string.
   *
   * @return The string; must not be {@code null}.
   */
  protected abstract String getString();

  /**
   * Un-caches the already-determined String. This can be used to implement mutable data structures.
   *
   * Important: Subclasses must carefully check {@link #isEffectivelyImmutable()} status.
   */
  protected void uncache() {
<span class="fc" id="L953">    theString = null;</span>
<span class="fc" id="L954">  }</span>

  /**
   * Provides the contents of this {@link StringHolder} as a {@link Reader}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  public final Reader toReader() throws IOException {
<span class="fc" id="L963">    String s = theString;</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L965">      return new StringReader(s);</span>
    } else {
<span class="fc" id="L967">      return newReader();</span>
    }
  }

  /**
   * Checks if this {@link StringHolder} had some kind of unexpected condition.
   *
   * If so, {@link #getMinimumLength()} may be adjusted to a value smaller than its previous state.
   *
   * @return {@code true} if trouble was detected.
   */
  public final boolean checkError() {
<span class="fc" id="L979">    return trouble;</span>
  }

  /**
   * Signals that this instance had some kind of unexpected condition.
   *
   * @see #checkError()
   * @see #clearError()
   */
  protected final void setError() {
<span class="fc" id="L989">    trouble = true;</span>
<span class="fc" id="L990">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L992">      sc.setError(this);</span>
    }
<span class="fc" id="L994">  }</span>

  /**
   * Clears the trouble state of this instance.
   *
   * @see #checkError()
   * @see #setError()
   */
  protected final void clearError() {
<span class="fc" id="L1003">    trouble = false;</span>
<span class="fc" id="L1004">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L1006">      sc.clearError(this);</span>
    }
<span class="fc" id="L1008">  }</span>

  /**
   * Constructs a new {@link Reader} providing the contents of this {@link StringHolder}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  protected Reader newReader() throws IOException {
<span class="fc" id="L1017">    return LazyInitReader.withSupplier(() -&gt; new StringReader(StringHolder.this.toString()));</span>
  }

  /**
   * Returns the {@link StringHolderScope} associated with this {@link StringHolder}, or
   * {@code null} if no scope was associated.
   *
   * @return The scope, or {@code null}.
   */
  public final StringHolderScope getScope() {
<span class="fc" id="L1027">    return scope;</span>
  }

  /**
   * Sets the {@link StringHolderScope} associated with this {@link StringHolder}. Any previously
   * associated scope is removed from this instance and returned.
   *
   * @param newScope The new scope, or {@code null}/{@link StringHolderScope#NONE} to set &quot;no
   *          scope&quot;.
   * @return The old scope, or {@code null} if none was set before.
   */
  public final StringHolderScope updateScope(StringHolderScope newScope) {
<span class="fc bfc" id="L1039" title="All 2 branches covered.">    if (newScope == StringHolderScope.NONE) { // NOPMD.CompareObjectsWithEquals</span>
<span class="fc" id="L1040">      newScope = null;</span>
    }
<span class="fc" id="L1042">    StringHolderScope oldScope = this.scope;</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">    if (oldScope == newScope) { // NOPMD.CompareObjectsWithEquals</span>
<span class="fc" id="L1044">      return oldScope;</span>
    }

<span class="fc bfc" id="L1047" title="All 2 branches covered.">    if (oldScope != null) {</span>
      try {
<span class="fc" id="L1049">        oldScope.remove(this);</span>
<span class="fc" id="L1050">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L1051">        setError();</span>
<span class="fc" id="L1052">        throw e;</span>
<span class="fc" id="L1053">      }</span>
    }

<span class="fc bfc" id="L1056" title="All 2 branches covered.">    if (newScope != null) {</span>
      try {
<span class="fc" id="L1058">        newScope.add(this);</span>
<span class="fc" id="L1059">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L1060">        setError();</span>
<span class="fc" id="L1061">        throw e;</span>
<span class="fc" id="L1062">      }</span>
    }
<span class="fc" id="L1064">    this.scope = newScope;</span>
<span class="fc" id="L1065">    return oldScope;</span>
  }

  @Override
  public char charAt(int index) {
<span class="fc" id="L1070">    return toString().charAt(index);</span>
  }

  @Override
  public CharSequence subSequence(int start, int end) {
<span class="fc bfc" id="L1075" title="All 4 branches covered.">    if (start == 0 &amp;&amp; end == length()) {</span>
<span class="fc" id="L1076">      return this;</span>
    }
<span class="fc" id="L1078">    return toString().subSequence(start, end);</span>
  }

  /**
   * Returns something that can be used in {@link StringHolder#withContent(Object)} which then
   * yields the same output when calling {@link #toString()} on either instance.
   *
   * The returned object usually is this instance itself. However, this method may return a
   * simplified version of the content stored in this instance. For example, if the content already
   * is a string, the string is returned.
   *
   * @return The &quot;content&quot; of this instance, which could be the instance itself, or something else.
   * @see #withContent(Object)
   */
  public Object asContent() {
<span class="fc bfc" id="L1093" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L1094">      return toString();</span>
    }
<span class="fc" id="L1096">    return this;</span>
  }

  @Override
  public int compareTo(Object o) {
<span class="fc bfc" id="L1101" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L1102">      return compareTo((StringHolder) o);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">    } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L1104">      return compareTo((CharSequence) o);</span>
    } else {
<span class="fc" id="L1106">      throw new ClassCastException(&quot;Cannot compare &quot; + o.getClass());</span>
    }
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link String}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(CharSequence o) {
<span class="fc bfc" id="L1117" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L1118">      return compareTo((StringHolder) o);</span>
    }

<span class="fc bfc" id="L1121" title="All 2 branches covered.">    if (isKnownEmpty()) {</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">      if (CharSequenceReleaseShim.isEmpty(o)) {</span>
<span class="fc" id="L1123">        return 0;</span>
      } else {
<span class="fc" id="L1125">        return -1;</span>
      }
    }

<span class="fc" id="L1129">    return compareToDefault(o);</span>
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link StringHolder}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(StringHolder o) {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">    if (o.isKnownEmpty()) {</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">      if (isKnownEmpty()) {</span>
<span class="fc" id="L1141">        return 0;</span>
      }
<span class="fc bfc" id="L1143" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">      if (isString()) {</span>
<span class="fc" id="L1145">        return toString().compareTo(o.toString());</span>
      } else {
<span class="fc" id="L1147">        return compareTo(o.toString());</span>
      }
<span class="fc bfc" id="L1149" title="All 2 branches covered.">    } else if (isString()) {</span>
<span class="fc" id="L1150">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
    }

<span class="fc" id="L1153">    return compareToDefault(o);</span>
  }

  /**
   * Default implementation for comparing this instance with another {@link CharSequence} that is
   * not a {@link StringHolder}. Certain trivial checks were already performed, such as one or both
   * being known empty.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  @SuppressWarnings({&quot;PMD.CognitiveComplexity&quot;})
  protected final int compareToDefault(CharSequence o) {
<span class="fc" id="L1166">    int k = 0;</span>

<span class="fc bfc" id="L1168" title="All 4 branches covered.">    if (getMinimumLength() &gt; 0 &amp;&amp; CharSequenceReleaseShim.isEmpty(o)) {</span>
      // NOTE: we trust the StringHolder claim of minimum length
<span class="fc" id="L1170">      return 1;</span>
    }
<span class="fc" id="L1172">    int len2 = o.length();</span>

    int lim;
    char c1;
    try {
<span class="fc" id="L1177">      c1 = charAt(k);</span>
<span class="fc" id="L1178">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">      if (len2 == 0) {</span>
<span class="fc" id="L1180">        return 0;</span>
      } else {
<span class="fc" id="L1182">        return -1;</span>
      }
<span class="fc" id="L1184">    }</span>

    int len1;
<span class="fc bfc" id="L1187" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">      if (o instanceof String) {</span>
<span class="fc" id="L1189">        return toString().compareTo((String) o);</span>
      }
<span class="fc" id="L1191">      len1 = length();</span>
<span class="fc" id="L1192">      lim = Math.min(len1, len2);</span>
    } else {
<span class="fc bfc" id="L1194" title="All 2 branches covered.">      if (isLengthKnown()) {</span>
<span class="fc" id="L1195">        len1 = length();</span>
<span class="fc" id="L1196">        lim = Math.min(len1, len2);</span>
      } else {
<span class="fc" id="L1198">        len1 = Integer.MAX_VALUE;</span>
<span class="fc" id="L1199">        lim = len2;</span>
      }
    }

<span class="fc bfc" id="L1203" title="All 2 branches covered.">    while (k &lt; lim) {</span>
<span class="fc" id="L1204">      char c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1206">        return c1 - c2;</span>
      }
<span class="fc" id="L1208">      k++;</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">      if (k &lt; lim) {</span>
        try {
<span class="fc" id="L1211">          c1 = charAt(k);</span>
<span class="fc" id="L1212">        } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1213">          return -1;</span>
<span class="fc" id="L1214">        }</span>
      }
<span class="fc" id="L1216">    }</span>

<span class="fc bfc" id="L1218" title="All 2 branches covered.">    if (getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1219">      return 1;</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">    } else if (len1 == k) {</span>
<span class="fc" id="L1221">      return len1 - len2;</span>
    }
    try {
<span class="fc" id="L1224">      charAt(k);</span>
<span class="fc" id="L1225">      return 1;</span>
<span class="fc" id="L1226">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1227">      return 0;</span>
    }
  }

  /**
   * Default implementation for comparing this instance with another {@link StringHolder}. Certain
   * trivial checks were already performed, such as one or both being known empty or known being
   * string.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  @SuppressWarnings({&quot;PMD.NPathComplexity&quot;, &quot;PMD.CognitiveComplexity&quot;})
  protected int compareToDefault(StringHolder o) {
<span class="fc" id="L1241">    int k = 0;</span>

    char c1;
    char c2;
    try {
<span class="fc" id="L1246">      c1 = charAt(k);</span>
<span class="fc" id="L1247">    } catch (IndexOutOfBoundsException e) {</span>
      try {
<span class="fc" id="L1249">        o.charAt(k);</span>
<span class="fc" id="L1250">        return -1;</span>
<span class="fc" id="L1251">      } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1252">        return 0;</span>
      }
<span class="fc" id="L1254">    }</span>
    try {
<span class="fc" id="L1256">      c2 = o.charAt(k);</span>
<span class="fc" id="L1257">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1258">      return 1;</span>
<span class="fc" id="L1259">    }</span>

<span class="fc bfc" id="L1261" title="All 2 branches covered.">    if (c1 != c2) {</span>
<span class="fc" id="L1262">      return c1 - c2;</span>
    }

<span class="fc bfc" id="L1265" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L1266">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc" id="L1268">      return compareTo(o.toString());</span>
    }

<span class="fc" id="L1271">    boolean len1Known = isLengthKnown();</span>
<span class="fc" id="L1272">    boolean len2Known = o.isLengthKnown();</span>

<span class="fc bfc" id="L1274" title="All 4 branches covered.">    if (len1Known &amp;&amp; len2Known) {</span>
<span class="fc" id="L1275">      return compareBothLengthsKnown(o, k, length(), o.length());</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">    } else if (len1Known) {</span>
<span class="fc" id="L1277">      return compareOurLengthKnown(o, k, length());</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">    } else if (len2Known) {</span>
<span class="fc" id="L1279">      return compareOtherLengthKnown(o, k, o.length());</span>
    } else {
<span class="fc" id="L1281">      return compareBothLengthsUnknown(o, k);</span>
    }
  }

  private int compareBothLengthsKnown(StringHolder o, int k, int len1, int len2) {
<span class="fc" id="L1286">    int lim = Math.min(len1, len2);</span>

    char c1;
    char c2;

<span class="fc bfc" id="L1291" title="All 2 branches covered.">    while (k &lt; lim) {</span>
<span class="fc" id="L1292">      c1 = charAt(k);</span>
<span class="fc" id="L1293">      c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1295">        return c1 - c2;</span>
      }
<span class="fc" id="L1297">      k++;</span>
    }

<span class="fc" id="L1300">    return len1 - len2;</span>
  }

  private int compareOurLengthKnown(StringHolder o, int k, int len1) {
    char c1;
    char c2;

<span class="fc bfc" id="L1307" title="All 2 branches covered.">    while (k &lt; len1) {</span>
<span class="fc" id="L1308">      c1 = charAt(k);</span>
      try {
<span class="fc" id="L1310">        c2 = o.charAt(k);</span>
<span class="fc" id="L1311">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1312">        return 1;</span>
<span class="fc" id="L1313">      }</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1315">        return c1 - c2;</span>
      }
<span class="fc" id="L1317">      k++;</span>
    }

    try {
<span class="fc bfc" id="L1321" title="All 2 branches covered.">      if (o.getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1322">        return -1;</span>
      }
<span class="fc" id="L1324">      o.charAt(k);</span>
<span class="fc" id="L1325">      return -1;</span>
<span class="fc" id="L1326">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1327">      return 0;</span>
    }
  }

  private int compareOtherLengthKnown(StringHolder o, int k, int len2) {
    char c1;
    char c2;

<span class="fc bfc" id="L1335" title="All 2 branches covered.">    while (k &lt; len2) {</span>
      try {
<span class="fc" id="L1337">        c1 = charAt(k);</span>
<span class="fc" id="L1338">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1339">        return -1;</span>
<span class="fc" id="L1340">      }</span>
<span class="fc" id="L1341">      c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1343">        return c1 - c2;</span>
      }
<span class="fc" id="L1345">      k++;</span>
    }

    try {
<span class="fc bfc" id="L1349" title="All 2 branches covered.">      if (getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1350">        return 1;</span>
      }
<span class="fc" id="L1352">      charAt(k);</span>
<span class="fc" id="L1353">      return 1;</span>
<span class="fc" id="L1354">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1355">      return 0;</span>
    }
  }

  private int compareBothLengthsUnknown(StringHolder o, int k) {
    char c1;
    char c2;
    while (true) {
<span class="fc" id="L1363">      k++;</span>

      try {
<span class="fc" id="L1366">        c1 = charAt(k);</span>
<span class="fc" id="L1367">      } catch (IndexOutOfBoundsException e) {</span>
        try {
<span class="fc" id="L1369">          o.charAt(k);</span>
<span class="fc" id="L1370">          return -1;</span>
<span class="fc" id="L1371">        } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1372">          return 0;</span>
        }
<span class="fc" id="L1374">      }</span>
      try {
<span class="fc" id="L1376">        c2 = o.charAt(k);</span>
<span class="fc" id="L1377">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1378">        return 1;</span>
<span class="fc" id="L1379">      }</span>

<span class="fc bfc" id="L1381" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1382">        return c1 - c2;</span>
      }
    }
  }

  /**
   * Computes a partial hash code, using the given value as the seed.
   *
   * @param h The initial value (seed).
   * @return The updated hash code.
   */
  protected int updateHashCode(int h) {
<span class="fc" id="L1394">    int length = length();</span>

<span class="fc bfc" id="L1396" title="All 4 branches covered.">    if (h == 0 &amp;&amp; isString()) {</span>
<span class="fc" id="L1397">      return toString().hashCode();</span>
    }

<span class="fc bfc" id="L1400" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L1401">      h = 31 * h + charAt(i);</span>
    }
<span class="fc" id="L1403">    return h;</span>
  }

  /**
   * Checks if the given {@link StringHolder} is &lt;em&gt;effectively immutable&lt;/em&gt;.
   *
   * @return {@code true} if the contents aren't going to change.
   */
  public boolean isEffectivelyImmutable() {
<span class="fc" id="L1412">    return isString();</span>
  }

  /**
   * Marks this instance as &lt;em&gt;effectively immutable&lt;/em&gt;.
   */
  public void markEffectivelyImmutable() {
<span class="fc bfc" id="L1419" title="All 2 branches covered.">    if (!isEffectivelyImmutable()) {</span>
<span class="fc" id="L1420">      toString();</span>
    }
<span class="fc" id="L1422">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>