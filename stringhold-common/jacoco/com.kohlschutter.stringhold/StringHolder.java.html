<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringHolder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stringhold-common</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolder.java</span></div><h1>StringHolder.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Objects;
import java.util.function.Supplier;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;
import com.kohlschutter.util.ComparisonUtil;

/**
 * A {@link StringHolder} holds something that can &lt;em&gt;eventually&lt;/em&gt; turn into a string.
 *
 * {@link StringHolder}s may reduce string allocation in cases where the final string sequence is,
 * for example sent to a Writer (or other Appendable), discarded after a certain length, ignored
 * upon an exception thrown along the way, etc.
 *
 * Apart from reducing string concatenation-related allocations, {@link StringHolder}s may reduce
 * the end-to-end string life-cycle by allowing concurrency between construction and transmission:
 * The string can be transmitted while it's being constructed.
 *
 * Unlike regular stream-based approaches, a pre-rendered structure is available before transmission
 * starts. This means a transmission that is known to exceed certain limits can be stopped before a
 * single character is transmitted.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveClassLength&quot;})
public abstract class StringHolder extends CharSequenceReleaseShim implements CharSequence,
    HasLength, Comparable&lt;Object&gt; {

  String theString;

  private int minLength;
  private int expectedLength;

<span class="fc" id="L57">  private boolean trouble = false;</span>

<span class="fc" id="L59">  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)</span>
  private StringHolderScope scope = null;

  /**
   * Constructs a {@link StringHolder} with a zero minimum length.
   */
  protected StringHolder() {
<span class="fc" id="L66">    this(0);</span>
<span class="fc" id="L67">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length, use {@code 0} if no minimum
   * length is known.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   */
  protected StringHolder(int minLength) {
<span class="fc" id="L76">    this(minLength, minLength);</span>
<span class="fc" id="L77">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length (use {@code 0} if no minimum
   * length is known), and expected length.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   * @param expectedLength The expected length, which may be larger than the eventual actual length
   */
  protected StringHolder(int minLength, int expectedLength) {
<span class="fc" id="L87">    super();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (minLength &lt; 0) {</span>
<span class="fc" id="L89">      throw new IllegalArgumentException(&quot;Invalid minLength&quot;);</span>
    }
<span class="fc" id="L91">    this.minLength = minLength;</span>
<span class="fc" id="L92">    this.expectedLength = Math.max(minLength, expectedLength);</span>
<span class="fc" id="L93">  }</span>

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(Supplier&lt;?&gt; supplier) {
<span class="fc" id="L105">    return withSupplierMinimumLength(0, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L120">    return withSupplierMinimumLength(0, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L134">    return new SuppliedStringHolder(minLength, minLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L151">    return new SuppliedStringHolder(minLength, minLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L165">    return new SuppliedStringHolder(0, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L182">    return new SuppliedStringHolder(0, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      Supplier&lt;?&gt; supplier) {
<span class="fc" id="L198">    return new SuppliedStringHolder(minLength, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L216">    return new SuppliedStringHolder(minLength, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, Supplier&lt;?&gt; supplier) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L232">      return SimpleStringHolder.EMPTY_STRING;</span>
    }
<span class="fc" id="L234">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L253">      return SimpleStringHolder.EMPTY_STRING;</span>
    }
<span class="fc" id="L255">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplier(IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L268">    return new ReaderStringHolder(0, 0, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumLength(int minLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L282">    return new ReaderStringHolder(minLen, minLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierExpectedLength(int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L296">    return new ReaderStringHolder(0, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumAndExpectedLength(int minLen, int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L311">    return new ReaderStringHolder(minLen, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link StringHolder} with the given content.
   *
   * Unless the object already is a {@link StringHolder}, or is known to be empty, its contents are
   * converted to String. {@code null} objects are converted to {@code &quot;null&quot;}, in accordance with
   * {@link String#valueOf(Object)}.
   *
   * @param obj The object.
   * @return The {@link StringHolder} instance.
   */
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  public static StringHolder withContent(Object obj) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L327">      return SimpleStringHolder.NULL_STRING;</span>
    }
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (obj instanceof String) {</span>
<span class="fc" id="L330">      String s = (String) obj;</span>
<span class="fc" id="L331">      StringHolder sh = SimpleStringHolder.COMMON_STRINGS.get(s);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L333">        return sh;</span>
      }
<span class="fc" id="L335">      return new SimpleStringHolder(s);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L337">      return (StringHolder) obj;</span>
    } else {
<span class="fc bfc" id="L339" title="All 2 branches covered.">      if (obj instanceof CharSequence) {</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (CharSequenceReleaseShim.isEmpty((CharSequence) obj)) {</span>
<span class="fc" id="L341">          return SimpleStringHolder.EMPTY_STRING;</span>
        }
      } else {
<span class="fc" id="L344">        StringHolder sh = SimpleStringHolder.COMMON_STRINGS.get(obj);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (sh != null) {</span>
<span class="fc" id="L346">          return sh;</span>
        }
      }
<span class="fc" id="L349">      String s = String.valueOf(obj);</span>
<span class="fc" id="L350">      StringHolder sh = SimpleStringHolder.COMMON_STRINGS.get(s);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L352">        return sh;</span>
      }
<span class="fc" id="L354">      return new SimpleStringHolder(s);</span>
    }
  }

  /**
   * Returns the current minimum length of the expected string length in this {@link StringHolder}.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * NOTE: When using this parameter for optimizations (e.g., to speed-up equality checks), make
   * sure to also check {@link #checkError()}. When that method returns {@code true}, the minimum
   * length can actually not be guaranteed.
   *
   * @return The minimum length (but be sure to see {@link #checkError()}).
   */
  @Override
  public final int getMinimumLength() {
<span class="fc" id="L371">    return minLength;</span>
  }

  /**
   * Returns the current estimate of the length of the string in this {@link StringHolder}, which is
   * at least the {@link #getMinimumLength()} but could be substantially larger.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * @return The currently expected length.
   */
  @Override
  public final int getExpectedLength() {
<span class="fc" id="L384">    return expectedLength;</span>
  }

  /**
   * Updates the current estimate of the length of the string in this {@link StringHolder}.
   *
   * The value will be rounded to {@link #getMinimumLength()} if necessary.
   *
   * @param len The new expected length
   */
  public void setExpectedLength(int len) {
<span class="fc" id="L395">    resizeTo(getMinimumLength(), len);</span>
<span class="fc" id="L396">  }</span>

  /**
   * Sets the expected lengths (minimum and estimated) to the given values.
   *
   * @param min The new minimum length, must not be smaller than the current minimum (unless
   *          {@link #checkError()} is {@code true})
   * @param expected The new expected length (will be rounded up if less than {@code min}).
   * @return The new expected length (which may be adjusted to the new minimum).
   * @throws IllegalStateException if the value is negative, and {@link #checkError()} is
   *           {@code false}.
   */
  protected final int resizeTo(int min, int expected) {
<span class="fc" id="L409">    return resizeTo(min, expected, false);</span>
  }

  private int resizeTo(int min, int expected, boolean fromToString) {
<span class="fc" id="L413">    int oldMin = this.minLength;</span>
<span class="fc" id="L414">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L416" title="All 4 branches covered.">    if (!fromToString &amp;&amp; isString()) {</span>
      // unchanged
<span class="fc" id="L418">      return oldExpected;</span>
    }

<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (min &lt; oldMin) {</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">      if (checkError()) {</span>
        // throw away our previous expectations upon error
<span class="fc" id="L424">        expected = (min = Math.max(0, min));</span>
      } else {
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (fromToString) {</span>
<span class="fc" id="L427">          setError();</span>
<span class="fc" id="L428">          resizeTo(min, expected, false);</span>
<span class="fc" id="L429">          throw new IllegalStateException(&quot;Detected mispredicted minLength&quot;);</span>
        } else {
<span class="fc" id="L431">          throw new IllegalStateException(&quot;New minimum is smaller than current minimum&quot;);</span>
        }
      }
    }

<span class="fc" id="L436">    int el = (this.expectedLength = Math.max((this.minLength = min), expected));</span>

<span class="fc" id="L438">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L441">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L442">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L443">        setError();</span>
<span class="fc" id="L444">        throw e;</span>
<span class="fc" id="L445">      }</span>
    }

<span class="fc" id="L448">    return el;</span>
  }

  /**
   * Increases the expected lengths (minimum and estimated) by the given values.
   *
   * Any value that overflows {@link Integer#MAX_VALUE} will be capped at that limit.
   *
   * @param minBy The minimum length increment, must not be negative (unless {@link #checkError()}
   *          is {@code true})
   * @param expectedBy The expected length increment, may be negative; final length will be
   *          {@code &gt;= 0}.
   * @throws IllegalArgumentException if minBy is negative and {@link #checkError()} is
   *           {@code false}
   */
  protected final void resizeBy(int minBy, int expectedBy) {
<span class="fc" id="L464">    int oldMin = this.minLength;</span>
<span class="fc" id="L465">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">    if (minBy &lt; 0) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">      if (checkError()) {</span>
<span class="fc" id="L469">        this.minLength = Math.max(0, this.minLength + minBy);</span>
      } else {
<span class="fc" id="L471">        throw new IllegalArgumentException(&quot;Minimum length increment is negative&quot;);</span>
      }
<span class="fc bfc" id="L473" title="All 2 branches covered.">    } else if ((this.minLength += minBy) &lt; 0) {</span>
      // cannot express minimum length that large
<span class="fc" id="L475">      this.minLength = Integer.MAX_VALUE;</span>
    }
<span class="fc" id="L477">    this.expectedLength = Math.max(minLength, this.expectedLength + expectedBy);</span>

<span class="fc" id="L479">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L482">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L483">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L484">        setError();</span>
<span class="fc" id="L485">        throw e;</span>
<span class="fc" id="L486">      }</span>
    }
<span class="fc" id="L488">  }</span>

  /**
   * Returns the actual length of this instance's contents. This may trigger a conversion to
   * {@link String}.
   *
   * @return The actual length.
   */
  @Override
  public final int length() {
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (theString != null) {</span>
<span class="fc" id="L499">      return minLength;</span>
    } else {
<span class="fc" id="L501">      return resizeTo(computeLength(), 0);</span>
    }
  }

  /**
   * Computes the actual length of this instance's contents.
   *
   * By default, this is implemented as {@code toString().length()}.
   *
   * When overriding this method, make sure to also override {@link #isLengthKnown()}.
   *
   * @return The actual length.
   */
  protected int computeLength() {
<span class="fc" id="L515">    return toString().length();</span>
  }

  /**
   * Checks if this holder is currently backed by a plain {@link String}.
   *
   * @return {@code true} if currently backed by a plain {@link String}.
   */
  public final boolean isString() {
<span class="fc bfc" id="L524" title="All 2 branches covered.">    return theString != null;</span>
  }

  /**
   * Checks if this {@link StringHolder} is known to yield an empty {@link String}.
   *
   * @return {@code true} if known non-empty.
   */
  @Override
  public final boolean isKnownEmpty() {
<span class="fc bfc" id="L534" title="All 2 branches covered.">    if (minLength &gt; 0) {</span>
<span class="fc" id="L535">      return false;</span>
<span class="fc bfc" id="L536" title="All 4 branches covered.">    } else if (isLengthKnown() &amp;&amp; length() == 0) {</span>
<span class="fc" id="L537">      return true;</span>
    } else {
      String s;

<span class="fc bfc" id="L541" title="All 4 branches covered.">      return (s = theString) != null &amp;&amp; s.isEmpty();</span>
    }
  }

  @Override
  public final boolean isEmpty() {
<span class="fc bfc" id="L547" title="All 4 branches covered.">    return isKnownEmpty() || super.isEmpty();</span>
  }

  /**
   * Returns {@code true} if the actual length is known, i.e. {@link #getMinimumLength()} {@code ==}
   * {@link #getExpectedLength()} {@code == } {@link #length()}.
   *
   * By default, this is only true if {@link #isString()} {@code == true}, but subclasses may
   * override this check. When they do, they must include a check for {@code ||}
   * {@link #isString()}.
   *
   * @return {@code true} if the length in this holder is known.
   * @see #isKnownEmpty()
   */
  @Override
  public boolean isLengthKnown() {
<span class="fc" id="L563">    return isString();</span>
  }

  @Override
  public final int hashCode() {
<span class="fc" id="L568">    return toString().hashCode();</span>
  }

  @SuppressFBWarnings(&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;)
  @Override
  public final boolean equals(Object obj) {
<span class="fc bfc" id="L574" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L575">      return false;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">    } else if (obj == this) {</span>
<span class="fc" id="L577">      return true;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L579">      return equalsString((String) obj);</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L581">      return equalsStringHolder((StringHolder) obj);</span>
    } else {
<span class="fc" id="L583">      return false;</span>
    }
  }

  private boolean equalsString(String s) {
<span class="fc bfc" id="L588" title="All 4 branches covered.">    if (!checkError() &amp;&amp; s.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L589">      return false;</span>
    } else {
<span class="fc" id="L591">      return toString().equals(s);</span>
    }
  }

  private boolean equalsStringHolder(StringHolder obj) {
<span class="fc bfc" id="L596" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L597" title="All 4 branches covered.">      if (!obj.checkError() &amp;&amp; length() &lt; obj.getMinimumLength()) {</span>
<span class="fc" id="L598">        return false;</span>
      }
<span class="fc bfc" id="L600" title="All 2 branches covered.">    } else if (obj.isString()) {</span>
<span class="fc bfc" id="L601" title="All 4 branches covered.">      if (!checkError() &amp;&amp; obj.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L602">        return false;</span>
      }
    }

<span class="fc" id="L606">    return obj.equalsString(toString());</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Appendable out) throws IOException {
<span class="fc" id="L617">    appendToAndReturnLength(out);</span>
<span class="fc" id="L618">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}; this may
   * or may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuilder out) {
<span class="fc" id="L627">    appendToAndReturnLength(out);</span>
<span class="fc" id="L628">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuffer out) {
<span class="fc" id="L637">    appendToAndReturnLength(out);</span>
<span class="fc" id="L638">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}; this may or may
   * not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Writer out) throws IOException {
<span class="fc" id="L648">    appendToAndReturnLength(out);</span>
<span class="fc" id="L649">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Appendable out) throws IOException {
<span class="fc bfc" id="L661" title="All 2 branches covered.">    if (out instanceof Writer) {</span>
<span class="fc" id="L662">      return appendToAndReturnLength((Writer) out);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    } else if (out instanceof StringBuilder) {</span>
<span class="fc" id="L664">      return appendToAndReturnLength((StringBuilder) out);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">    } else if (out instanceof StringBuffer) {</span>
<span class="fc" id="L666">      return appendToAndReturnLength((StringBuffer) out);</span>
    } else {
<span class="fc" id="L668">      return appendToAndReturnLengthDefault(out);</span>
    }
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuilder out) {
    int len;
<span class="fc bfc" id="L682" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L683">      len = length();</span>
<span class="fc" id="L684">      out.append(toString());</span>
    } else {
<span class="fc" id="L686">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L688">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L691">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuffer out) {
    int len;
<span class="fc bfc" id="L704" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L705">      len = length();</span>
<span class="fc" id="L706">      out.append(toString());</span>
    } else {
<span class="fc" id="L708">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L710">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L713">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Writer out) throws IOException {
    int len;
<span class="fc bfc" id="L727" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L728">      len = length();</span>
<span class="fc" id="L729">      out.append(toString());</span>
    } else {
<span class="fc" id="L731">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L733">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L736">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable} (which is
   * neither a {@link StringBuilder}, {@link StringBuffer}, nor a {@link Writer}), and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @see #appendToAndReturnLength(StringBuilder)
   * @see #appendToAndReturnLength(StringBuffer)
   * @see #appendToAndReturnLength(StringWriter)
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthDefaultImpl(Appendable out) throws IOException {
<span class="fc" id="L753">    String s = toString();</span>
<span class="fc" id="L754">    out.append(s);</span>
<span class="fc" id="L755">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuilder out) {
<span class="fc" id="L767">    String s = toString();</span>
<span class="fc" id="L768">    out.append(s);</span>
<span class="fc" id="L769">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuffer out) {
<span class="fc" id="L781">    String s = toString();</span>
<span class="fc" id="L782">    out.append(s);</span>
<span class="fc" id="L783">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthImpl(Writer out) throws IOException {
    // subclasses may implement a better way for Writers, but we don't
<span class="fc" id="L797">    return appendToAndReturnLengthDefault(out);</span>
  }

  private int appendToAndReturnLengthDefault(Appendable out) throws IOException {
    int len;
<span class="fc bfc" id="L802" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L803">      len = length();</span>
<span class="fc" id="L804">      out.append(toString());</span>
    } else {
<span class="fc" id="L806">      len = appendToAndReturnLengthDefaultImpl(out);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L808">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L811">    return len;</span>
  }

  @Override
  public final String toString() {
<span class="fc" id="L816">    String s = theString;</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L818">      return s;</span>
    }
<span class="fc" id="L820">    synchronized (this) {</span>
      try {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (isKnownEmpty()) {</span>
<span class="fc" id="L823">          theString = s = &quot;&quot;;</span>
        } else {
<span class="fc" id="L825">          theString = s = Objects.requireNonNull(getString());</span>
        }
<span class="fc" id="L827">        resizeTo(s.length(), 0, true);</span>
<span class="fc" id="L828">      } catch (RuntimeException e) {</span>
<span class="fc" id="L829">        s = theString;</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">        if (s != null) {</span>
<span class="fc" id="L831">          resizeTo(s.length(), 0, true);</span>
        }
<span class="fc" id="L833">        setError();</span>
<span class="fc" id="L834">        throw e;</span>
<span class="fc" id="L835">      }</span>

<span class="fc" id="L837">      stringSanityCheck(s);</span>
<span class="fc" id="L838">      return s;</span>
    }
  }

  /**
   * Called from within {@link #toString()} after updating/assigning the cached string but before
   * returning it. This may be a good opportunity to see if we got what we wanted, setError, etc.
   *
   * @param s The string.
   */
  protected void stringSanityCheck(String s) {
<span class="fc" id="L849">  }</span>

  /**
   * Retrieves the string.
   *
   * @return The string; must not be {@code null}.
   */
  protected abstract String getString();

  /**
   * Un-caches the already-determined String. This can be used to implement mutable data structures.
   */
  protected void uncache() {
<span class="fc" id="L862">    theString = null;</span>
<span class="fc" id="L863">  }</span>

  /**
   * Provides the contents of this {@link StringHolder} as a {@link Reader}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  public final Reader toReader() throws IOException {
<span class="fc" id="L872">    String s = theString;</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L874">      return new StringReader(s);</span>
    } else {
<span class="fc" id="L876">      return newReader();</span>
    }
  }

  /**
   * Checks if this {@link StringHolder} had some kind of unexpected condition.
   *
   * If so, {@link #getMinimumLength()} may be adjusted to a value smaller than its previous state.
   *
   * @return {@code true} if trouble was detected.
   */
  public final boolean checkError() {
<span class="fc" id="L888">    return trouble;</span>
  }

  /**
   * Signals that this instance had some kind of unexpected condition.
   *
   * @see #checkError()
   * @see #clearError()
   */
  protected final void setError() {
<span class="fc" id="L898">    trouble = true;</span>
<span class="fc" id="L899">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L901">      sc.setError(this);</span>
    }
<span class="fc" id="L903">  }</span>

  /**
   * Clears the trouble state of this instance.
   *
   * @see #checkError()
   * @see #setError()
   */
  protected final void clearError() {
<span class="fc" id="L912">    trouble = false;</span>
<span class="fc" id="L913">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L915">      sc.clearError(this);</span>
    }
<span class="fc" id="L917">  }</span>

  /**
   * Constructs a new {@link Reader} providing the contents of this {@link StringHolder}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  protected Reader newReader() throws IOException {
<span class="fc" id="L926">    return LazyInitReader.withSupplier(() -&gt; new StringReader(StringHolder.this.toString()));</span>
  }

  /**
   * Returns the {@link StringHolderScope} associated with this {@link StringHolder}, or
   * {@code null} if no scope was associated.
   *
   * @return The scope, or {@code null}.
   */
  public final StringHolderScope getScope() {
<span class="fc" id="L936">    return scope;</span>
  }

  /**
   * Sets the {@link StringHolderScope} associated with this {@link StringHolder}. Any previously
   * associated scope is removed from this instance and returned.
   *
   * @param newScope The new scope, or {@code null}/{@link StringHolderScope#NONE} to set &quot;no
   *          scope&quot;.
   * @return The old scope, or {@code null} if none was set before.
   */
  public final StringHolderScope updateScope(StringHolderScope newScope) {
<span class="fc bfc" id="L948" title="All 2 branches covered.">    if (newScope == StringHolderScope.NONE) { // NOPMD</span>
<span class="fc" id="L949">      newScope = null;</span>
    }
<span class="fc" id="L951">    StringHolderScope oldScope = this.scope;</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">    if (oldScope != null) {</span>
      try {
<span class="fc" id="L954">        oldScope.remove(this);</span>
<span class="fc" id="L955">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L956">        setError();</span>
<span class="fc" id="L957">        throw e;</span>
<span class="fc" id="L958">      }</span>
    }

<span class="fc bfc" id="L961" title="All 2 branches covered.">    if (newScope != null) {</span>
      try {
<span class="fc" id="L963">        newScope.add(this);</span>
<span class="fc" id="L964">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L965">        setError();</span>
<span class="fc" id="L966">        throw e;</span>
<span class="fc" id="L967">      }</span>
    }
<span class="fc" id="L969">    this.scope = newScope;</span>
<span class="fc" id="L970">    return oldScope;</span>
  }

  @Override
  public char charAt(int index) {
<span class="fc" id="L975">    return toString().charAt(index);</span>
  }

  @Override
  public CharSequence subSequence(int start, int end) {
<span class="fc bfc" id="L980" title="All 4 branches covered.">    if (start == 0 &amp;&amp; end == length()) {</span>
<span class="fc" id="L981">      return this;</span>
    }
<span class="fc" id="L983">    return toString().subSequence(start, end);</span>
  }

  /**
   * Returns something that can be used in {@link StringHolder#withContent(Object)} which then
   * yields the same output when calling {@link #toString()} on either instance.
   *
   * The returned object usually is this instance itself. However, this method may return a
   * simplified version of the content stored in this instance. For example, if the content already
   * is a string, the string is returned.
   *
   * @return The &quot;content&quot; of this instance, which could be the instance itself, or something else.
   * @see #withContent(Object)
   */
  public Object asContent() {
<span class="fc bfc" id="L998" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L999">      return toString();</span>
    }
<span class="fc" id="L1001">    return this;</span>
  }

  @Override
  public int compareTo(Object o) {
<span class="fc bfc" id="L1006" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L1007">      return compareTo((StringHolder) o);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">    } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L1009">      return compareTo((CharSequence) o);</span>
    } else {
<span class="fc" id="L1011">      throw new ClassCastException(&quot;Cannot compare &quot; + o.getClass());</span>
    }
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link String}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(CharSequence o) {
<span class="fc bfc" id="L1022" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L1023">      return compareTo((StringHolder) o);</span>
    }

<span class="fc bfc" id="L1026" title="All 2 branches covered.">    if (isKnownEmpty()) {</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">      if (CharSequenceReleaseShim.isEmpty(o)) {</span>
<span class="fc" id="L1028">        return 0;</span>
      } else {
<span class="fc" id="L1030">        return -1;</span>
      }
    }

<span class="fc" id="L1034">    return compareToDefault(o);</span>
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link StringHolder}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(StringHolder o) {
<span class="fc bfc" id="L1044" title="All 2 branches covered.">    if (o.isKnownEmpty()) {</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">      if (isKnownEmpty()) {</span>
<span class="fc" id="L1046">        return 0;</span>
      }
<span class="fc bfc" id="L1048" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">      if (isString()) {</span>
<span class="fc" id="L1050">        return toString().compareTo(o.toString());</span>
      } else {
<span class="fc" id="L1052">        return compareTo(o.toString());</span>
      }
<span class="fc bfc" id="L1054" title="All 2 branches covered.">    } else if (isString()) {</span>
<span class="fc" id="L1055">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
    }

<span class="fc" id="L1058">    return compareToDefault(o);</span>
  }

  /**
   * Default implementation for comparing this instance with another {@link CharSequence} that is
   * not a {@link StringHolder}. Certain trivial checks were already performed, such as one or both
   * being known empty.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  @SuppressWarnings({&quot;PMD.CognitiveComplexity&quot;})
  protected final int compareToDefault(CharSequence o) {
<span class="fc" id="L1071">    int k = 0;</span>

<span class="fc bfc" id="L1073" title="All 4 branches covered.">    if (getMinimumLength() &gt; 0 &amp;&amp; CharSequenceReleaseShim.isEmpty(o)) {</span>
      // NOTE: we trust the StringHolder claim of minimum length
<span class="fc" id="L1075">      return 1;</span>
    }
<span class="fc" id="L1077">    int len2 = o.length();</span>

    int lim;
    char c1;
    try {
<span class="fc" id="L1082">      c1 = charAt(k);</span>
<span class="fc" id="L1083">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">      if (len2 == 0) {</span>
<span class="fc" id="L1085">        return 0;</span>
      } else {
<span class="fc" id="L1087">        return -1;</span>
      }
<span class="fc" id="L1089">    }</span>

    int len1;
<span class="fc bfc" id="L1092" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">      if (o instanceof String) {</span>
<span class="fc" id="L1094">        return toString().compareTo((String) o);</span>
      }
<span class="fc" id="L1096">      len1 = length();</span>
<span class="fc" id="L1097">      lim = Math.min(len1, len2);</span>
    } else {
<span class="fc bfc" id="L1099" title="All 2 branches covered.">      if (isLengthKnown()) {</span>
<span class="fc" id="L1100">        len1 = length();</span>
<span class="fc" id="L1101">        lim = Math.min(len1, len2);</span>
      } else {
<span class="fc" id="L1103">        len1 = Integer.MAX_VALUE;</span>
<span class="fc" id="L1104">        lim = len2;</span>
      }
    }

<span class="fc bfc" id="L1108" title="All 2 branches covered.">    while (k &lt; lim) {</span>
<span class="fc" id="L1109">      char c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1111">        return c1 - c2;</span>
      }
<span class="fc" id="L1113">      k++;</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">      if (k &lt; lim) {</span>
        try {
<span class="fc" id="L1116">          c1 = charAt(k);</span>
<span class="fc" id="L1117">        } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1118">          return -1;</span>
<span class="fc" id="L1119">        }</span>
      }
<span class="fc" id="L1121">    }</span>

<span class="fc bfc" id="L1123" title="All 2 branches covered.">    if (getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1124">      return 1;</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">    } else if (len1 == k) {</span>
<span class="fc" id="L1126">      return len1 - len2;</span>
    }
    try {
<span class="fc" id="L1129">      charAt(k);</span>
<span class="fc" id="L1130">      return 1;</span>
<span class="fc" id="L1131">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1132">      return 0;</span>
    }
  }

  /**
   * Default implementation for comparing this instance with another {@link StringHolder}. Certain
   * trivial checks were already performed, such as one or both being known empty or known being
   * string.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  @SuppressWarnings({&quot;PMD.NPathComplexity&quot;, &quot;PMD.CognitiveComplexity&quot;})
  protected int compareToDefault(StringHolder o) {
<span class="fc" id="L1146">    int k = 0;</span>

    char c1;
    char c2;
    try {
<span class="fc" id="L1151">      c1 = charAt(k);</span>
<span class="fc" id="L1152">    } catch (IndexOutOfBoundsException e) {</span>
      try {
<span class="fc" id="L1154">        o.charAt(k);</span>
<span class="fc" id="L1155">        return -1;</span>
<span class="fc" id="L1156">      } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1157">        return 0;</span>
      }
<span class="fc" id="L1159">    }</span>
    try {
<span class="fc" id="L1161">      c2 = o.charAt(k);</span>
<span class="fc" id="L1162">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1163">      return 1;</span>
<span class="fc" id="L1164">    }</span>

<span class="fc bfc" id="L1166" title="All 2 branches covered.">    if (c1 != c2) {</span>
<span class="fc" id="L1167">      return c1 - c2;</span>
    }

<span class="fc bfc" id="L1170" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L1171">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc" id="L1173">      return compareTo(o.toString());</span>
    }

<span class="fc" id="L1176">    boolean len1Known = isLengthKnown();</span>
<span class="fc" id="L1177">    boolean len2Known = o.isLengthKnown();</span>

<span class="fc bfc" id="L1179" title="All 4 branches covered.">    if (len1Known &amp;&amp; len2Known) {</span>
<span class="fc" id="L1180">      return compareBothLengthsKnown(o, k, length(), o.length());</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">    } else if (len1Known) {</span>
<span class="fc" id="L1182">      return compareOurLengthKnown(o, k, length());</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">    } else if (len2Known) {</span>
<span class="fc" id="L1184">      return compareOtherLengthKnown(o, k, o.length());</span>
    } else {
<span class="fc" id="L1186">      return compareBothLengthsUnknown(o, k);</span>
    }
  }

  private int compareBothLengthsKnown(StringHolder o, int k, int len1, int len2) {
<span class="fc" id="L1191">    int lim = Math.min(len1, len2);</span>

    char c1;
    char c2;

<span class="fc bfc" id="L1196" title="All 2 branches covered.">    while (k &lt; lim) {</span>
<span class="fc" id="L1197">      c1 = charAt(k);</span>
<span class="fc" id="L1198">      c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1200">        return c1 - c2;</span>
      }
<span class="fc" id="L1202">      k++;</span>
    }

<span class="fc" id="L1205">    return len1 - len2;</span>
  }

  private int compareOurLengthKnown(StringHolder o, int k, int len1) {
    char c1;
    char c2;

<span class="fc bfc" id="L1212" title="All 2 branches covered.">    while (k &lt; len1) {</span>
<span class="fc" id="L1213">      c1 = charAt(k);</span>
      try {
<span class="fc" id="L1215">        c2 = o.charAt(k);</span>
<span class="fc" id="L1216">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1217">        return 1;</span>
<span class="fc" id="L1218">      }</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1220">        return c1 - c2;</span>
      }
<span class="fc" id="L1222">      k++;</span>
    }

    try {
<span class="fc bfc" id="L1226" title="All 2 branches covered.">      if (o.getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1227">        return -1;</span>
      }
<span class="fc" id="L1229">      o.charAt(k);</span>
<span class="fc" id="L1230">      return -1;</span>
<span class="fc" id="L1231">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1232">      return 0;</span>
    }
  }

  private int compareOtherLengthKnown(StringHolder o, int k, int len2) {
    char c1;
    char c2;

<span class="fc bfc" id="L1240" title="All 2 branches covered.">    while (k &lt; len2) {</span>
      try {
<span class="fc" id="L1242">        c1 = charAt(k);</span>
<span class="fc" id="L1243">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1244">        return -1;</span>
<span class="fc" id="L1245">      }</span>
<span class="fc" id="L1246">      c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1248">        return c1 - c2;</span>
      }
<span class="fc" id="L1250">      k++;</span>
    }

    try {
<span class="fc bfc" id="L1254" title="All 2 branches covered.">      if (getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1255">        return 1;</span>
      }
<span class="fc" id="L1257">      charAt(k);</span>
<span class="fc" id="L1258">      return 1;</span>
<span class="fc" id="L1259">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1260">      return 0;</span>
    }
  }

  private int compareBothLengthsUnknown(StringHolder o, int k) {
    char c1;
    char c2;
    while (true) {
<span class="fc" id="L1268">      k++;</span>

      try {
<span class="fc" id="L1271">        c1 = charAt(k);</span>
<span class="fc" id="L1272">      } catch (IndexOutOfBoundsException e) {</span>
        try {
<span class="fc" id="L1274">          o.charAt(k);</span>
<span class="fc" id="L1275">          return -1;</span>
<span class="fc" id="L1276">        } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1277">          return 0;</span>
        }
<span class="fc" id="L1279">      }</span>
      try {
<span class="fc" id="L1281">        c2 = o.charAt(k);</span>
<span class="fc" id="L1282">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1283">        return 1;</span>
<span class="fc" id="L1284">      }</span>

<span class="fc bfc" id="L1286" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1287">        return c1 - c2;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>