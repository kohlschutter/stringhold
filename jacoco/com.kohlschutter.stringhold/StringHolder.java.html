<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringHolder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stringhold</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolder.java</span></div><h1>StringHolder.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Objects;
import java.util.function.Supplier;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;
import com.kohlschutter.util.ComparisonUtil;

/**
 * A {@link StringHolder} holds something that can &lt;em&gt;eventually&lt;/em&gt; turn into a string.
 *
 * {@link StringHolder}s may reduce string allocation in cases where the final string sequence is,
 * for example sent to a Writer (or other Appendable), discarded after a certain length, ignored
 * upon an exception thrown along the way, etc.
 *
 * Apart from reducing string concatenation-related allocations, {@link StringHolder}s may reduce
 * the end-to-end string life-cycle by allowing concurrency between construction and transmission:
 * The string can be transmitted while it's being constructed.
 *
 * Unlike regular stream-based approaches, a pre-rendered structure is available before transmission
 * starts. This means a transmission that is known to exceed certain limits can be stopped before a
 * single character is transmitted.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveClassLength&quot;})
public abstract class StringHolder extends CharSequenceReleaseShim implements CharSequence,
    HasLength, Comparable&lt;Object&gt; {

  String theString;

  private int minLength;
  private int expectedLength;

<span class="fc" id="L57">  private boolean trouble = false;</span>

<span class="fc" id="L59">  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)</span>
  private StringHolderScope scope = null;

  /**
   * Constructs a {@link StringHolder} with a zero minimum length.
   */
  protected StringHolder() {
<span class="fc" id="L66">    this(0);</span>
<span class="fc" id="L67">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length, use {@code 0} if no minimum
   * length is known.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   */
  protected StringHolder(int minLength) {
<span class="fc" id="L76">    this(minLength, minLength);</span>
<span class="fc" id="L77">  }</span>

  /**
   * Constructs a {@link StringHolder} with the given minimum length (use {@code 0} if no minimum
   * length is known), and expected length.
   *
   * @param minLength The minimum length, which must not be larger than the eventual actual length.
   * @param expectedLength The expected length, which may be larger than the eventual actual length
   */
  protected StringHolder(int minLength, int expectedLength) {
<span class="fc" id="L87">    super();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (minLength &lt; 0) {</span>
<span class="fc" id="L89">      throw new IllegalArgumentException(&quot;Invalid minLength&quot;);</span>
    }
<span class="fc" id="L91">    this.minLength = minLength;</span>
<span class="fc" id="L92">    this.expectedLength = Math.max(minLength, expectedLength);</span>
<span class="fc" id="L93">  }</span>

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(Supplier&lt;?&gt; supplier) {
<span class="fc" id="L105">    return withSupplierMinimumLength(0, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplier(IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L120">    return withSupplierMinimumLength(0, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L134">    return new SuppliedStringHolder(minLength, minLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumLength(int minLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L151">    return new SuppliedStringHolder(minLength, minLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L165">    return new SuppliedStringHolder(0, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierExpectedLength(int expectedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L182">    return new SuppliedStringHolder(0, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      Supplier&lt;?&gt; supplier) {
<span class="fc" id="L198">    return new SuppliedStringHolder(minLength, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L216">    return new SuppliedStringHolder(minLength, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, Supplier&lt;?&gt; supplier) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L232">      return SimpleStringHolder.EMPTY_STRING;</span>
    }
<span class="fc" id="L234">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withSupplierFixedLength(int fixedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L253">      return SimpleStringHolder.EMPTY_STRING;</span>
    }
<span class="fc" id="L255">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplier(IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L268">    return new ReaderStringHolder(0, 0, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumLength(int minLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L282">    return new ReaderStringHolder(minLen, minLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierExpectedLength(int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L296">    return new ReaderStringHolder(0, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  public static StringHolder withReaderSupplierMinimumAndExpectedLength(int minLen, int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L311">    return new ReaderStringHolder(minLen, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link StringHolder} with the given content.
   *
   * Unless the object already is a {@link StringHolder}, or is known to be empty, its contents are
   * converted to String.
   *
   * @param obj The object.
   * @return The {@link StringHolder} instance.
   */
  public static StringHolder withContent(Object obj) {
<span class="fc bfc" id="L324" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L325">      return SimpleStringHolder.EMPTY_STRING;</span>
    }
<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (obj instanceof String) {</span>
<span class="fc" id="L328">      String s = (String) obj;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      if (s.isEmpty()) {</span>
<span class="fc" id="L330">        return SimpleStringHolder.EMPTY_STRING;</span>
      }
<span class="fc" id="L332">      return new SimpleStringHolder(s);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L334">      return (StringHolder) obj;</span>
    } else {
<span class="fc bfc" id="L336" title="All 2 branches covered.">      if (obj instanceof CharSequence) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (CharSequenceReleaseShim.isEmpty((CharSequence) obj)) {</span>
<span class="fc" id="L338">          return SimpleStringHolder.EMPTY_STRING;</span>
        }
      }
<span class="fc" id="L341">      String s = String.valueOf(obj);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">      if (s.isEmpty()) {</span>
<span class="fc" id="L343">        return SimpleStringHolder.EMPTY_STRING;</span>
      }
<span class="fc" id="L345">      return new SimpleStringHolder(s);</span>
    }
  }

  /**
   * Returns the current minimum length of the expected string length in this {@link StringHolder}.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * NOTE: When using this parameter for optimizations (e.g., to speed-up equality checks), make
   * sure to also check {@link #checkError()}. When that method returns {@code true}, the minimum
   * length can actually not be guaranteed.
   *
   * @return The minimum length (but be sure to see {@link #checkError()}).
   */
  @Override
  public final int getMinimumLength() {
<span class="fc" id="L362">    return minLength;</span>
  }

  /**
   * Returns the current estimate of the length of the string in this {@link StringHolder}, which is
   * at least the {@link #getMinimumLength()} but could be substantially larger.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * @return The currently expected length.
   */
  @Override
  public final int getExpectedLength() {
<span class="fc" id="L375">    return expectedLength;</span>
  }

  /**
   * Updates the current estimate of the length of the string in this {@link StringHolder}.
   *
   * The value will be rounded to {@link #getMinimumLength()} if necessary.
   *
   * @param len The new expected length
   */
  public void setExpectedLength(int len) {
<span class="fc" id="L386">    resizeTo(getMinimumLength(), len);</span>
<span class="fc" id="L387">  }</span>

  /**
   * Sets the expected lengths (minimum and estimated) to the given values.
   *
   * @param min The new minimum length, must not be smaller than the current minimum (unless
   *          {@link #checkError()} is {@code true})
   * @param expected The new expected length (will be rounded up if less than {@code min}).
   * @return The new expected length (which may be adjusted to the new minimum).
   * @throws IllegalStateException if the value is negative, and {@link #checkError()} is
   *           {@code false}.
   */
  protected final int resizeTo(int min, int expected) {
<span class="fc" id="L400">    return resizeTo(min, expected, false);</span>
  }

  private int resizeTo(int min, int expected, boolean fromToString) {
<span class="fc" id="L404">    int oldMin = this.minLength;</span>
<span class="fc" id="L405">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L407" title="All 4 branches covered.">    if (!fromToString &amp;&amp; isString()) {</span>
      // unchanged
<span class="fc" id="L409">      return oldExpected;</span>
    }

<span class="fc bfc" id="L412" title="All 2 branches covered.">    if (min &lt; oldMin) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">      if (checkError()) {</span>
        // throw away our previous expectations upon error
<span class="fc" id="L415">        expected = (min = Math.max(0, min));</span>
      } else {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (fromToString) {</span>
<span class="fc" id="L418">          setError();</span>
<span class="fc" id="L419">          resizeTo(min, expected, false);</span>
<span class="fc" id="L420">          throw new IllegalStateException(&quot;Detected mispredicted minLength&quot;);</span>
        } else {
<span class="fc" id="L422">          throw new IllegalStateException(&quot;New minimum is smaller than current minimum&quot;);</span>
        }
      }
    }

<span class="fc" id="L427">    int el = (this.expectedLength = Math.max((this.minLength = min), expected));</span>

<span class="fc" id="L429">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L432">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L433">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L434">        setError();</span>
<span class="fc" id="L435">        throw e;</span>
<span class="fc" id="L436">      }</span>
    }

<span class="fc" id="L439">    return el;</span>
  }

  /**
   * Increases the expected lengths (minimum and estimated) by the given values.
   *
   * Any value that overflows {@link Integer#MAX_VALUE} will be capped at that limit.
   *
   * @param minBy The minimum length increment, must not be negative (unless {@link #checkError()}
   *          is {@code true})
   * @param expectedBy The expected length increment, may be negative; final length will be
   *          {@code &gt;= 0}.
   * @throws IllegalArgumentException if minBy is negative and {@link #checkError()} is
   *           {@code false}
   */
  protected final void resizeBy(int minBy, int expectedBy) {
<span class="fc" id="L455">    int oldMin = this.minLength;</span>
<span class="fc" id="L456">    int oldExpected = this.expectedLength;</span>

<span class="fc bfc" id="L458" title="All 2 branches covered.">    if (minBy &lt; 0) {</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">      if (checkError()) {</span>
<span class="fc" id="L460">        this.minLength = Math.max(0, this.minLength + minBy);</span>
      } else {
<span class="fc" id="L462">        throw new IllegalArgumentException(&quot;Minimum length increment is negative&quot;);</span>
      }
<span class="fc bfc" id="L464" title="All 2 branches covered.">    } else if ((this.minLength += minBy) &lt; 0) {</span>
      // cannot express minimum length that large
<span class="fc" id="L466">      this.minLength = Integer.MAX_VALUE;</span>
    }
<span class="fc" id="L468">    this.expectedLength = Math.max(minLength, this.expectedLength + expectedBy);</span>

<span class="fc" id="L470">    StringHolderScope sc = this.scope;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">    if (sc != null) {</span>
      try {
<span class="fc" id="L473">        sc.resizeBy(this, this.minLength - oldMin, this.expectedLength - oldExpected);</span>
<span class="fc" id="L474">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L475">        setError();</span>
<span class="fc" id="L476">        throw e;</span>
<span class="fc" id="L477">      }</span>
    }
<span class="fc" id="L479">  }</span>

  /**
   * Returns the actual length of this instance's contents. This may trigger a conversion to
   * {@link String}.
   *
   * @return The actual length.
   */
  @Override
  public final int length() {
<span class="fc bfc" id="L489" title="All 2 branches covered.">    if (theString != null) {</span>
<span class="fc" id="L490">      return minLength;</span>
    } else {
<span class="fc" id="L492">      return resizeTo(computeLength(), 0);</span>
    }
  }

  /**
   * Computes the actual length of this instance's contents.
   *
   * By default, this is implemented as {@code toString().length()}.
   *
   * When overriding this method, make sure to also override {@link #isLengthKnown()}.
   *
   * @return The actual length.
   */
  protected int computeLength() {
<span class="fc" id="L506">    return toString().length();</span>
  }

  /**
   * Checks if this holder is currently backed by a plain {@link String}.
   *
   * @return {@code true} if currently backed by a plain {@link String}.
   */
  public final boolean isString() {
<span class="fc bfc" id="L515" title="All 2 branches covered.">    return theString != null;</span>
  }

  /**
   * Checks if this {@link StringHolder} is known to yield an empty {@link String}.
   *
   * @return {@code true} if known non-empty.
   */
  @Override
  public final boolean isKnownEmpty() {
<span class="fc bfc" id="L525" title="All 2 branches covered.">    if (minLength &gt; 0) {</span>
<span class="fc" id="L526">      return false;</span>
<span class="fc bfc" id="L527" title="All 4 branches covered.">    } else if (isLengthKnown() &amp;&amp; length() == 0) {</span>
<span class="fc" id="L528">      return true;</span>
    } else {
      String s;

<span class="fc bfc" id="L532" title="All 4 branches covered.">      return (s = theString) != null &amp;&amp; s.isEmpty();</span>
    }
  }

  @Override
  public final boolean isEmpty() {
<span class="fc bfc" id="L538" title="All 4 branches covered.">    return isKnownEmpty() || super.isEmpty();</span>
  }

  /**
   * Returns {@code true} if the actual length is known, i.e. {@link #getMinimumLength()} {@code ==}
   * {@link #getExpectedLength()} {@code == } {@link #length()}.
   *
   * By default, this is only true if {@link #isString()} {@code == true}, but subclasses may
   * override this check. When they do, they must include a check for {@code ||}
   * {@link #isString()}.
   *
   * @return {@code true} if the length in this holder is known.
   * @see #isKnownEmpty()
   */
  @Override
  public boolean isLengthKnown() {
<span class="fc" id="L554">    return isString();</span>
  }

  @Override
  public final int hashCode() {
<span class="fc" id="L559">    return toString().hashCode();</span>
  }

  @SuppressFBWarnings(&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;)
  @Override
  public final boolean equals(Object obj) {
<span class="fc bfc" id="L565" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L566">      return false;</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">    } else if (obj == this) {</span>
<span class="fc" id="L568">      return true;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L570">      return equalsString((String) obj);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L572">      return equalsStringHolder((StringHolder) obj);</span>
    } else {
<span class="fc" id="L574">      return false;</span>
    }
  }

  private boolean equalsString(String s) {
<span class="fc bfc" id="L579" title="All 4 branches covered.">    if (!checkError() &amp;&amp; s.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L580">      return false;</span>
    } else {
<span class="fc" id="L582">      return toString().equals(s);</span>
    }
  }

  private boolean equalsStringHolder(StringHolder obj) {
<span class="fc bfc" id="L587" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L588" title="All 4 branches covered.">      if (!obj.checkError() &amp;&amp; length() &lt; obj.getMinimumLength()) {</span>
<span class="fc" id="L589">        return false;</span>
      }
<span class="fc bfc" id="L591" title="All 2 branches covered.">    } else if (obj.isString()) {</span>
<span class="fc bfc" id="L592" title="All 4 branches covered.">      if (!checkError() &amp;&amp; obj.length() &lt; getMinimumLength()) {</span>
<span class="fc" id="L593">        return false;</span>
      }
    }

<span class="fc" id="L597">    return obj.equalsString(toString());</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Appendable out) throws IOException {
<span class="fc" id="L608">    appendToAndReturnLength(out);</span>
<span class="fc" id="L609">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}; this may
   * or may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuilder out) {
<span class="fc" id="L618">    appendToAndReturnLength(out);</span>
<span class="fc" id="L619">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  public final void appendTo(StringBuffer out) {
<span class="fc" id="L628">    appendToAndReturnLength(out);</span>
<span class="fc" id="L629">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}; this may or may
   * not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  public final void appendTo(Writer out) throws IOException {
<span class="fc" id="L639">    appendToAndReturnLength(out);</span>
<span class="fc" id="L640">  }</span>

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Appendable out) throws IOException {
<span class="fc bfc" id="L652" title="All 2 branches covered.">    if (out instanceof Writer) {</span>
<span class="fc" id="L653">      return appendToAndReturnLength((Writer) out);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">    } else if (out instanceof StringBuilder) {</span>
<span class="fc" id="L655">      return appendToAndReturnLength((StringBuilder) out);</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">    } else if (out instanceof StringBuffer) {</span>
<span class="fc" id="L657">      return appendToAndReturnLength((StringBuffer) out);</span>
    } else {
<span class="fc" id="L659">      return appendToAndReturnLengthDefault(out);</span>
    }
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuilder out) {
    int len;
<span class="fc bfc" id="L673" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L674">      len = length();</span>
<span class="fc" id="L675">      out.append(toString());</span>
    } else {
<span class="fc" id="L677">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L679">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L682">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  public final int appendToAndReturnLength(StringBuffer out) {
    int len;
<span class="fc bfc" id="L695" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L696">      len = length();</span>
<span class="fc" id="L697">      out.append(toString());</span>
    } else {
<span class="fc" id="L699">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L701">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L704">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  public final int appendToAndReturnLength(Writer out) throws IOException {
    int len;
<span class="fc bfc" id="L718" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L719">      len = length();</span>
<span class="fc" id="L720">      out.append(toString());</span>
    } else {
<span class="fc" id="L722">      len = appendToAndReturnLengthImpl(out);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L724">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L727">    return len;</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable} (which is
   * neither a {@link StringBuilder}, {@link StringBuffer}, nor a {@link Writer}), and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @see #appendToAndReturnLength(StringBuilder)
   * @see #appendToAndReturnLength(StringBuffer)
   * @see #appendToAndReturnLength(StringWriter)
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthDefaultImpl(Appendable out) throws IOException {
<span class="fc" id="L744">    String s = toString();</span>
<span class="fc" id="L745">    out.append(s);</span>
<span class="fc" id="L746">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuilder out) {
<span class="fc" id="L758">    String s = toString();</span>
<span class="fc" id="L759">    out.append(s);</span>
<span class="fc" id="L760">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   */
  protected int appendToAndReturnLengthImpl(StringBuffer out) {
<span class="fc" id="L772">    String s = toString();</span>
<span class="fc" id="L773">    out.append(s);</span>
<span class="fc" id="L774">    return s.length();</span>
  }

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String. It won't be called if it's already one.
   *
   * @param out The target.
   * @return The number of characters appended (which is assumed to be the new minimum length).
   * @throws IOException on error.
   */
  protected int appendToAndReturnLengthImpl(Writer out) throws IOException {
    // subclasses may implement a better way for Writers, but we don't
<span class="fc" id="L788">    return appendToAndReturnLengthDefault(out);</span>
  }

  private int appendToAndReturnLengthDefault(Appendable out) throws IOException {
    int len;
<span class="fc bfc" id="L793" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L794">      len = length();</span>
<span class="fc" id="L795">      out.append(toString());</span>
    } else {
<span class="fc" id="L797">      len = appendToAndReturnLengthDefaultImpl(out);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">      if (minLength &lt; len) {</span>
<span class="fc" id="L799">        resizeTo(len, 0);</span>
      }
    }
<span class="fc" id="L802">    return len;</span>
  }

  @Override
  public final String toString() {
<span class="fc" id="L807">    String s = theString;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L809">      return s;</span>
    }
<span class="fc" id="L811">    synchronized (this) {</span>
      try {
<span class="fc" id="L813">        theString = s = Objects.requireNonNull(getString());</span>
<span class="fc" id="L814">        resizeTo(s.length(), 0, true);</span>
<span class="fc" id="L815">      } catch (RuntimeException e) {</span>
<span class="fc" id="L816">        s = theString;</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (s != null) {</span>
<span class="fc" id="L818">          resizeTo(s.length(), 0, true);</span>
        }
<span class="fc" id="L820">        setError();</span>
<span class="fc" id="L821">        throw e;</span>
<span class="fc" id="L822">      }</span>

<span class="fc" id="L824">      stringSanityCheck(s);</span>
<span class="fc" id="L825">      return s;</span>
    }
  }

  /**
   * Called from within {@link #toString()} after updating/assigning the cached string but before
   * returning it. This may be a good opportunity to see if we got what we wanted, setError, etc.
   *
   * @param s The string.
   */
  protected void stringSanityCheck(String s) {
<span class="fc" id="L836">  }</span>

  /**
   * Retrieves the string.
   *
   * @return The string; must not be {@code null}.
   */
  protected abstract String getString();

  /**
   * Un-caches the already-determined String. This can be used to implement mutable data structures.
   */
  protected void uncache() {
<span class="fc" id="L849">    theString = null;</span>
<span class="fc" id="L850">  }</span>

  /**
   * Provides the contents of this {@link StringHolder} as a {@link Reader}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  public final Reader toReader() throws IOException {
<span class="fc" id="L859">    String s = theString;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L861">      return new StringReader(s);</span>
    } else {
<span class="fc" id="L863">      return newReader();</span>
    }
  }

  /**
   * Checks if this {@link StringHolder} had some kind of unexpected condition.
   *
   * If so, {@link #getMinimumLength()} may be adjusted to a value smaller than its previous state.
   *
   * @return {@code true} if trouble was detected.
   */
  public final boolean checkError() {
<span class="fc" id="L875">    return trouble;</span>
  }

  /**
   * Signals that this instance had some kind of unexpected condition.
   *
   * @see #checkError()
   * @see #clearError()
   */
  protected final void setError() {
<span class="fc" id="L885">    trouble = true;</span>
<span class="fc" id="L886">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L888">      sc.setError(this);</span>
    }
<span class="fc" id="L890">  }</span>

  /**
   * Clears the trouble state of this instance.
   *
   * @see #checkError()
   * @see #setError()
   */
  protected final void clearError() {
<span class="fc" id="L899">    trouble = false;</span>
<span class="fc" id="L900">    StringHolderScope sc = scope;</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">    if (sc != null) {</span>
<span class="fc" id="L902">      sc.clearError(this);</span>
    }
<span class="fc" id="L904">  }</span>

  /**
   * Constructs a new {@link Reader} providing the contents of this {@link StringHolder}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  protected Reader newReader() throws IOException {
<span class="fc" id="L913">    return LazyInitReader.withSupplier(() -&gt; new StringReader(StringHolder.this.toString()));</span>
  }

  /**
   * Returns the {@link StringHolderScope} associated with this {@link StringHolder}, or
   * {@code null} if no scope was associated.
   *
   * @return The scope, or {@code null}.
   */
  public final StringHolderScope getScope() {
<span class="fc" id="L923">    return scope;</span>
  }

  /**
   * Sets the {@link StringHolderScope} associated with this {@link StringHolder}. Any previously
   * associated scope is removed from this instance and returned.
   *
   * @param newScope The new scope, or {@code null}/{@link StringHolderScope#NONE} to set &quot;no
   *          scope&quot;.
   * @return The old scope, or {@code null} if none was set before.
   */
  public final StringHolderScope updateScope(StringHolderScope newScope) {
<span class="fc bfc" id="L935" title="All 2 branches covered.">    if (newScope == StringHolderScope.NONE) { // NOPMD</span>
<span class="fc" id="L936">      newScope = null;</span>
    }
<span class="fc" id="L938">    StringHolderScope oldScope = this.scope;</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">    if (oldScope != null) {</span>
      try {
<span class="fc" id="L941">        oldScope.remove(this);</span>
<span class="fc" id="L942">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L943">        setError();</span>
<span class="fc" id="L944">        throw e;</span>
<span class="fc" id="L945">      }</span>
    }

<span class="fc bfc" id="L948" title="All 2 branches covered.">    if (newScope != null) {</span>
      try {
<span class="fc" id="L950">        newScope.add(this);</span>
<span class="fc" id="L951">      } catch (RuntimeException | Error e) {</span>
<span class="fc" id="L952">        setError();</span>
<span class="fc" id="L953">        throw e;</span>
<span class="fc" id="L954">      }</span>
    }
<span class="fc" id="L956">    this.scope = newScope;</span>
<span class="fc" id="L957">    return oldScope;</span>
  }

  @Override
  public char charAt(int index) {
<span class="fc" id="L962">    return toString().charAt(index);</span>
  }

  @Override
  public CharSequence subSequence(int start, int end) {
<span class="fc bfc" id="L967" title="All 4 branches covered.">    if (start == 0 &amp;&amp; end == length()) {</span>
<span class="fc" id="L968">      return this;</span>
    }
<span class="fc" id="L970">    return toString().subSequence(start, end);</span>
  }

  /**
   * Returns something that can be used in {@link StringHolder#withContent(Object)} which then
   * yields the same output when calling {@link #toString()} on either instance.
   *
   * The returned object usually is this instance itself. However, this method may return a
   * simplified version of the content stored in this instance. For example, if the content already
   * is a string, the string is returned.
   *
   * @return The &quot;content&quot; of this instance, which could be the instance itself, or something else.
   * @see #withContent(Object)
   */
  public Object asContent() {
<span class="fc bfc" id="L985" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L986">      return toString();</span>
    }
<span class="fc" id="L988">    return this;</span>
  }

  @Override
  public int compareTo(Object o) {
<span class="fc bfc" id="L993" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L994">      return compareTo((StringHolder) o);</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">    } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L996">      return compareTo((CharSequence) o);</span>
    } else {
<span class="fc" id="L998">      throw new ClassCastException(&quot;Cannot compare &quot; + o.getClass());</span>
    }
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link String}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(CharSequence o) {
<span class="fc bfc" id="L1009" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L1010">      return compareTo((StringHolder) o);</span>
    }

<span class="fc bfc" id="L1013" title="All 2 branches covered.">    if (isKnownEmpty()) {</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">      if (CharSequenceReleaseShim.isEmpty(o)) {</span>
<span class="fc" id="L1015">        return 0;</span>
      } else {
<span class="fc" id="L1017">        return -1;</span>
      }
    }

<span class="fc" id="L1021">    return compareToDefault(o);</span>
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link StringHolder}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  public int compareTo(StringHolder o) {
<span class="fc bfc" id="L1031" title="All 2 branches covered.">    if (o.isKnownEmpty()) {</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">      if (isKnownEmpty()) {</span>
<span class="fc" id="L1033">        return 0;</span>
      }
<span class="fc bfc" id="L1035" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">      if (isString()) {</span>
<span class="fc" id="L1037">        return toString().compareTo(o.toString());</span>
      } else {
<span class="fc" id="L1039">        return compareTo(o.toString());</span>
      }
<span class="fc bfc" id="L1041" title="All 2 branches covered.">    } else if (isString()) {</span>
<span class="fc" id="L1042">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
    }

<span class="fc" id="L1045">    return compareToDefault(o);</span>
  }

  /**
   * Default implementation for comparing this instance with another {@link CharSequence} that is
   * not a {@link StringHolder}. Certain trivial checks were already performed, such as one or both
   * being known empty.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  protected final int compareToDefault(CharSequence o) {
<span class="fc" id="L1057">    int k = 0;</span>

<span class="fc bfc" id="L1059" title="All 4 branches covered.">    if (getMinimumLength() &gt; 0 &amp;&amp; CharSequenceReleaseShim.isEmpty(o)) {</span>
      // NOTE: we trust the StringHolder claim of minimum length
<span class="fc" id="L1061">      return 1;</span>
    }
<span class="fc" id="L1063">    int len2 = o.length();</span>

    int lim;
    char c1;
    try {
<span class="fc" id="L1068">      c1 = charAt(k);</span>
<span class="fc" id="L1069">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">      if (len2 == 0) {</span>
<span class="fc" id="L1071">        return 0;</span>
      } else {
<span class="fc" id="L1073">        return -1;</span>
      }
<span class="fc" id="L1075">    }</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">      if (o instanceof String) {</span>
<span class="fc" id="L1078">        return toString().compareTo((String) o);</span>
      }
<span class="fc" id="L1080">      lim = Math.min(length(), len2);</span>
    } else {
<span class="fc" id="L1082">      lim = len2;</span>
    }

<span class="fc bfc" id="L1085" title="All 2 branches covered.">    while (k &lt; lim) {</span>
<span class="fc" id="L1086">      char c2 = o.charAt(k);</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1088">        return c1 - c2;</span>
      }
<span class="fc" id="L1090">      k++;</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">      if (k &lt; lim) {</span>
        try {
<span class="fc" id="L1093">          c1 = charAt(k);</span>
<span class="fc" id="L1094">        } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1095">          return -1;</span>
<span class="fc" id="L1096">        }</span>
      }
<span class="fc" id="L1098">    }</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">    if (getMinimumLength() &gt; k) {</span>
<span class="fc" id="L1100">      return 1;</span>
    }
    try {
<span class="fc" id="L1103">      charAt(k);</span>
<span class="fc" id="L1104">      return 1;</span>
<span class="fc" id="L1105">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1106">      return 0;</span>
    }
  }

  /**
   * Default implementation for comparing this instance with another {@link StringHolder}. Certain
   * trivial checks were already performed, such as one or both being known empty or known being
   * string.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  protected int compareToDefault(StringHolder o) {
<span class="fc" id="L1119">    int k = 0;</span>

    char c1;
    char c2;
    try {
<span class="fc" id="L1124">      c1 = charAt(k);</span>
<span class="fc" id="L1125">    } catch (IndexOutOfBoundsException e) {</span>
      try {
<span class="fc" id="L1127">        o.charAt(k);</span>
<span class="fc" id="L1128">        return -1;</span>
<span class="fc" id="L1129">      } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1130">        return 0;</span>
      }
<span class="fc" id="L1132">    }</span>
    try {
<span class="fc" id="L1134">      c2 = o.charAt(k);</span>
<span class="fc" id="L1135">    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1136">      return 1;</span>
<span class="fc" id="L1137">    }</span>

<span class="fc bfc" id="L1139" title="All 2 branches covered.">    if (c1 != c2) {</span>
<span class="fc" id="L1140">      return c1 - c2;</span>
    }

<span class="fc bfc" id="L1143" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L1144">      return ComparisonUtil.reverseComparisonResult(o.compareTo(toString()));</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">    } else if (o.isString()) {</span>
<span class="fc" id="L1146">      return compareTo(o.toString());</span>
    }

    while (true) {
<span class="fc" id="L1150">      k++;</span>

      try {
<span class="fc" id="L1153">        c1 = charAt(k);</span>
<span class="fc" id="L1154">      } catch (IndexOutOfBoundsException e) {</span>
        try {
<span class="fc" id="L1156">          o.charAt(k);</span>
<span class="fc" id="L1157">          return -1;</span>
<span class="fc" id="L1158">        } catch (IndexOutOfBoundsException e2) {</span>
<span class="fc" id="L1159">          return 0;</span>
        }
<span class="fc" id="L1161">      }</span>
      try {
<span class="fc" id="L1163">        c2 = o.charAt(k);</span>
<span class="fc" id="L1164">      } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L1165">        return 1;</span>
<span class="fc" id="L1166">      }</span>

<span class="fc bfc" id="L1168" title="All 2 branches covered.">      if (c1 != c2) {</span>
<span class="fc" id="L1169">        return c1 - c2;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>