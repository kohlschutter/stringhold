<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringHolder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">stringhold-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">stringhold-common</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolder.java</span></div><h1>StringHolder.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022, 2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.PrimitiveIterator;
import java.util.concurrent.Executor;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * A {@link StringHolder} holds something that can &lt;em&gt;eventually&lt;/em&gt; turn into a string.
 *
 * {@link StringHolder}s may reduce string allocation in cases where the final string sequence is,
 * for example sent to a Writer (or other Appendable), discarded after a certain length, ignored
 * upon an exception thrown along the way, etc.
 *
 * Apart from reducing string concatenation-related allocations, {@link StringHolder}s may reduce
 * the end-to-end string life-cycle by allowing concurrency between construction and transmission:
 * The string can be transmitted while it's being constructed.
 *
 * Unlike regular stream-based approaches, a pre-rendered structure is available before transmission
 * starts. This means a transmission that is known to exceed certain limits can be stopped before a
 * single character is transmitted.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings(&quot;PMD.ExcessivePublicCount&quot;)
public interface StringHolder extends CharSequence, HasLength, Comparable&lt;Object&gt;, Cloneable {
  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplier(Supplier&lt;?&gt; supplier) {
<span class="fc" id="L57">    return withSupplierMinimumLength(0, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplier(IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L72">    return withSupplierMinimumLength(0, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumLength(int minLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L86">    return new SuppliedStringHolder(minLength, minLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumLength(int minLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L103">    return new SuppliedStringHolder(minLength, minLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierExpectedLength(int expectedLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L117">    return new SuppliedStringHolder(0, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierExpectedLength(int expectedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L134">    return new SuppliedStringHolder(0, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      Supplier&lt;?&gt; supplier) {
<span class="fc" id="L150">    return new SuppliedStringHolder(minLength, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L168">    return new SuppliedStringHolder(minLength, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierFixedLength(int fixedLength, Supplier&lt;?&gt; supplier) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L184">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L186">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierFixedLength(int fixedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L205">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L207">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplier(IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L220">    return new ReaderStringHolder(0, 0, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierMinimumLength(int minLen, IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L234">    return new ReaderStringHolder(minLen, minLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierExpectedLength(int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L248">    return new ReaderStringHolder(0, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierMinimumAndExpectedLength(int minLen, int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L263">    return new ReaderStringHolder(minLen, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newSequence() {
<span class="fc" id="L272">    return new StringHolderSequence();</span>
  }

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newSequence(int estimatedNumberOfAppends) {
<span class="fc" id="L284">    return new StringHolderSequence(estimatedNumberOfAppends);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence() {
<span class="fc" id="L296">    return new AsyncStringHolderSequence();</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param executor The executor to use.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence(Executor executor) {
<span class="fc" id="L310">    return new AsyncStringHolderSequence(executor);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence(int estimatedNumberOfAppends) {
<span class="fc" id="L325">    return new AsyncStringHolderSequence(estimatedNumberOfAppends);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   * @param executor The executor to use.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newAsyncSequence(int estimatedNumberOfAppends, Executor executor) {
<span class="fc" id="L341">    return new AsyncStringHolderSequence(estimatedNumberOfAppends, executor);</span>
  }

  /**
   * Constructs a {@link StringHolder} with the given content.
   *
   * Unless the object already is a {@link StringHolder}, or is known to be empty, its contents are
   * converted to String. {@code null} objects are converted to {@code &quot;null&quot;}, in accordance with
   * {@link String#valueOf(Object)}.
   *
   * @param obj The object.
   * @return The {@link StringHolder} instance.
   */
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  static StringHolder withContent(Object obj) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L357">      return CommonStrings.NULL_STRINGHOLDER;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L359">      String s = (String) obj;</span>
<span class="fc" id="L360">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L362">        return sh;</span>
      }
<span class="fc" id="L364">      return new SimpleStringHolder(s);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L366">      return (StringHolder) obj;</span>
    } else {
<span class="fc bfc" id="L368" title="All 2 branches covered.">      if (obj instanceof CharSequence) {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (CharSequenceReleaseShim.isEmpty((CharSequence) obj)) {</span>
<span class="fc" id="L370">          return CommonStrings.EMPTY_STRINGHOLDER;</span>
        }
      } else {
<span class="fc" id="L373">        StringHolder sh = CommonStrings.lookup(obj);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (sh != null) {</span>
<span class="fc" id="L375">          return sh;</span>
        }
      }
<span class="fc" id="L378">      String s = String.valueOf(obj);</span>
<span class="fc" id="L379">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L381">        return sh;</span>
      }
<span class="fc" id="L383">      return new SimpleStringHolder(s);</span>
    }
  }

  /**
   * Constructs a {@link StringHolder} with the given content sequences, as if they had been
   * appended to a {@link StringHolderSequence}. Empty sequences are optimized.
   *
   * @param objects The objects to represent as a sequence; if {@code null}, a StringHolder of the
   *          string {@code &quot;null&quot;} is returned.
   * @return The {@link StringHolder} instance.
   * @see #withContent(Object)
   */
  static StringHolder withContent(Object... objects) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">    if (objects == null) {</span>
<span class="fc" id="L398">      return CommonStrings.NULL_STRINGHOLDER;</span>
    }
<span class="fc bfc" id="L400" title="All 3 branches covered.">    switch (objects.length) {</span>
      case 0:
<span class="fc" id="L402">        return CommonStrings.EMPTY_STRINGHOLDER;</span>
      case 1:
<span class="fc" id="L404">        return withContent(objects[0]);</span>
      default:
        // see below
    }
<span class="fc" id="L408">    StringHolderSequence seq = new StringHolderSequence(objects.length);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    for (Object obj : objects) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (((StringHolder) obj).isKnownEmpty()) {</span>
<span class="fc" id="L412">          continue;</span>
        }
<span class="fc bfc" id="L414" title="All 4 branches covered.">      } else if (obj instanceof CharSequence &amp;&amp; CharSequenceReleaseShim.isEmpty(</span>
          (CharSequence) obj)) {
<span class="fc" id="L416">        continue;</span>
      }
<span class="fc" id="L418">      seq.append(obj);</span>
    }
<span class="fc bfc" id="L420" title="All 2 branches covered.">    if (seq.numberOfAppends() == 0) {</span>
<span class="fc" id="L421">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    } else {
<span class="fc" id="L423">      return seq;</span>
    }
  }

  /**
   * Constructs a conditional wrapper around the given {@link StringHolder}; the given
   * {@code include} supplier controls whether the {@link StringHolder} is included, or effectively
   * empty.
   *
   * The conditional supplier is called at most once; the check is delayed as much as possible.
   *
   * @param wrapped The wrapped {@link StringHolder}.
   * @param includePredicate Controls the inclusion of that {@link StringHolder}; {@code false}
   *          means &quot;excluded&quot;.
   * @return the conditional {@link StringHolder}.
   */
  static StringHolder withConditionalStringHolder(StringHolder wrapped,
      Predicate&lt;StringHolder&gt; includePredicate) {
<span class="fc" id="L441">    return new ConditionalStringHolder(wrapped, includePredicate);</span>
  }

  /**
   * Constructs a wrapper around the given {@link StringHolder}, marking it as &quot;uncacheable&quot; (i.e.,
   * {@link #isCacheable()} returning {@code false}, unless {@link #isString()} is {@code true}).
   *
   * @param wrapped The wrapped {@link StringHolder}.
   * @return the uncacheable {@link StringHolder}.
   */
  static StringHolder withUncacheableStringHolder(StringHolder wrapped) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">    return wrapped.isCacheable() ? withConditionalStringHolder(wrapped, (k) -&gt; true) : wrapped;</span>
  }

  @Override
  default boolean isEmpty() {
<span class="fc bfc" id="L457" title="All 2 branches covered.">    return length() == 0;</span>
  }

  /**
   * Checks if this holder is currently backed by a plain {@link String}.
   *
   * @return {@code true} if currently backed by a plain {@link String}.
   */
  boolean isString();

  /**
   * Provides the contents of this {@link StringHolder} as a {@link Reader}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  Reader toReader() throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  void appendTo(Appendable out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}; this may
   * or may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  void appendTo(StringBuilder out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  void appendTo(StringBuffer out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}; this may or may
   * not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  void appendTo(Writer out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  int appendToAndReturnLength(Appendable out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  int appendToAndReturnLength(StringBuilder out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  int appendToAndReturnLength(StringBuffer out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  int appendToAndReturnLength(Writer out) throws IOException;

  /**
   * Returns the current minimum length of the expected string length in this {@link StringHolder}.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * NOTE: When using this parameter for optimizations (e.g., to speed-up equality checks), make
   * sure to also check {@link #checkError()}. When that method returns {@code true}, the minimum
   * length can actually not be guaranteed.
   *
   * @return The minimum length (but be sure to see {@link #checkError()}).
   */
  @Override
  int getMinimumLength();

  /**
   * Returns the current estimate of the length of the string in this {@link StringHolder}, which is
   * at least the {@link #getMinimumLength()} but could be substantially larger.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * @return The currently expected length.
   */
  @Override
  int getExpectedLength();

  /**
   * Updates the current estimate of the length of the string in this {@link StringHolder}.
   *
   * The value will be rounded to {@link #getMinimumLength()} if necessary.
   *
   * @param len The new expected length
   */
  void setExpectedLength(int len);

  /**
   * Returns the actual length of this instance's contents. This may trigger a conversion to
   * {@link String}.
   *
   * @return The actual length.
   */
  @Override
  int length();

  /**
   * Checks if this {@link StringHolder} is known to yield an empty {@link String}.
   *
   * @return {@code true} if known non-empty.
   */
  @Override
  boolean isKnownEmpty();

  /**
   * Returns {@code true} if the actual length is known, i.e. {@link #getMinimumLength()} {@code ==}
   * {@link #getExpectedLength()} {@code == } {@link #length()}.
   *
   * By default, this is only true if {@link #isString()} {@code == true}, but subclasses may
   * override this check. When they do, they must include a check for
   * {@code || super.isLengthKnown()}.
   *
   * Note that once a length is &lt;em&gt;known&lt;/em&gt;, it cannot change (i.e., don't override this for
   * mutable objects like {@link StringHolderSequence}).
   *
   * @return {@code true} if the length in this holder is known.
   * @see #isKnownEmpty()
   */
  @Override
  boolean isLengthKnown();

  /**
   * Checks if this {@link StringHolder} had some kind of unexpected condition.
   *
   * If so, {@link #getMinimumLength()} may be adjusted to a value smaller than its previous state.
   *
   * @return {@code true} if trouble was detected.
   */
  boolean checkError();

  /**
   * Returns the {@link StringHolderScope} associated with this {@link StringHolder}, or
   * {@code null} if no scope was associated.
   *
   * @return The scope, or {@code null}.
   */
  StringHolderScope getScope();

  /**
   * Sets the {@link StringHolderScope} associated with this {@link StringHolder}. Any previously
   * associated scope is removed from this instance and returned.
   *
   * @param newScope The new scope, or {@code null}/{@link StringHolderScope#NONE} to set &quot;no
   *          scope&quot;.
   * @return The old scope, or {@code null} if none was set before.
   */
  StringHolderScope updateScope(StringHolderScope newScope);

  /**
   * Returns something that can be used in {@link StringHolder#withContent(Object)} which then
   * yields the same output when calling {@link #toString()} on either instance.
   *
   * The returned object usually is this instance itself. However, this method may return a
   * simplified version of the content stored in this instance. For example, if the content already
   * is a string, the string is returned.
   *
   * @return The &quot;content&quot; of this instance, which could be the instance itself, or something else.
   * @see #withContent(Object)
   */
  Object asContent();

  @Override
  default int compareTo(Object o) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L662">      return compareTo((StringHolder) o);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L664">      return compareTo((CharSequence) o);</span>
    } else {
<span class="fc" id="L666">      throw new ClassCastException(&quot;Cannot compare &quot; + o.getClass());</span>
    }
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link String}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  int compareTo(CharSequence o);

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link StringHolder}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  int compareTo(StringHolder o);

  /**
   * Checks if this {@link StringHolder} is &lt;em&gt;effectively immutable&lt;/em&gt;.
   *
   * @return {@code true} if the contents aren't going to change.
   */
  boolean isEffectivelyImmutable();

  /**
   * Marks this instance as &lt;em&gt;effectively immutable&lt;/em&gt;.
   */
  void markEffectivelyImmutable();

  /**
   * Checks if this {@link StringHolder} is cacheable. A cacheable {@link StringHolder} may be
   * probed early for its contents (length, hashCode, etc.). This is usually the case, except when a
   * {@link StringHolder} is involved that was supplied via
   * {@link StringHolder#withConditionalStringHolder(StringHolder, Predicate)} or via
   * {@link #withUncacheableStringHolder(StringHolder)}, and that StringHolder is not already a
   * string or otherwise supplied, for example. By convention, it should be cacheable whenever
   * {@link #isString()} is {@code true}.
   *
   * @return {@code true} if cacheable.
   */
  default boolean isCacheable() {
<span class="fc" id="L710">    return true;</span>
  }

  /**
   * Deep-clones this {@link StringHolder}.
   *
   * @return The cloned instance.
   */
  StringHolder clone();

  /**
   * Returns the index within this string of the first occurrence of the specified character, or
   * {@code -1} if not found.
   *
   * @param c The character/codepoint to look for.
   * @return The position, or {@code -1} if not found.
   */
  default int indexOf(int c) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L729">      return toString().indexOf(c);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">    } else if (isKnownEmpty()) {</span>
<span class="fc" id="L731">      return -1;</span>
    }

<span class="fc" id="L734">    int i = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">    for (PrimitiveIterator.OfInt it = chars().iterator(); it.hasNext(); i++) {</span>
<span class="fc" id="L736">      int ch = it.next();</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">      if (ch == c) {</span>
<span class="fc" id="L738">        return i;</span>
      }
    }
<span class="fc" id="L741">    return -1;</span>
  }

  /**
   * Checks if this {@link StringHolder} contains the given {@link CharSequence}.
   * 
   * @param s The char sequence to look for.
   * @return {@code true} if found (also if the sequence is empty).
   */
  default boolean contains(CharSequence s) {
<span class="fc bfc" id="L751" title="All 2 branches covered.">    return indexOf(s.toString()) &gt;= 0;</span>
  }

  /**
   * Returns the index within this {@link StringHolder} of the first occurrence of the specified
   * {@link CharSequence}, or {@code -1} if not found.
   *
   * @param str The char sequence to look for.
   * @return The position, or {@code -1} if not found.
   */
  default int indexOf(CharSequence str) {
<span class="fc bfc" id="L762" title="All 2 branches covered.">    if (str == this) { // NOPMD.CompareObjectsWithEquals</span>
<span class="fc" id="L763">      return 0;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">    } else if (isString()) {</span>
<span class="fc bfc" id="L765" title="All 4 branches covered.">      if (str instanceof String || //</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">          (str instanceof StringHolder &amp;&amp; ((StringHolder) str).isString())) {</span>
<span class="fc" id="L767">        return toString().indexOf(str.toString());</span>
      }
    }

<span class="fc bfc" id="L771" title="All 2 branches covered.">    if (CharSequenceReleaseShim.isEmpty(str)) {</span>
<span class="fc" id="L772">      return 0;</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">    } else if (isKnownEmpty()) {</span>
<span class="fc" id="L774">      return -1;</span>
    }

<span class="fc" id="L777">    int strLen = str.length();</span>
<span class="fc bfc" id="L778" title="All 4 branches covered.">    if (isLengthKnown() &amp;&amp; length() &lt; strLen) {</span>
<span class="fc" id="L779">      return -1;</span>
    }

<span class="fc" id="L782">    int stri = 0;</span>
<span class="fc" id="L783">    int i = 0;</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">    for (PrimitiveIterator.OfInt it = chars().iterator(); it.hasNext(); i++) {</span>
<span class="fc" id="L785">      int c = it.next();</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">      if (c == str.charAt(stri)) {</span>
<span class="fc" id="L787">        stri++;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (stri == strLen) {</span>
<span class="fc" id="L789">          return i - strLen + 1;</span>
        }
      } else {
<span class="fc" id="L792">        stri = 0;</span>
      }
    }
<span class="fc" id="L795">    return -1;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>