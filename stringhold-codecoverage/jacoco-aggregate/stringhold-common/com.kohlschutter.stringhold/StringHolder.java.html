<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringHolder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">stringhold-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">stringhold-common</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolder.java</span></div><h1>StringHolder.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022, 2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.PrimitiveIterator;
import java.util.concurrent.Executor;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * A {@link StringHolder} holds something that can &lt;em&gt;eventually&lt;/em&gt; turn into a string.
 *
 * {@link StringHolder}s may reduce string allocation in cases where the final string sequence is,
 * for example sent to a Writer (or other Appendable), discarded after a certain length, ignored
 * upon an exception thrown along the way, etc.
 *
 * Apart from reducing string concatenation-related allocations, {@link StringHolder}s may reduce
 * the end-to-end string life-cycle by allowing concurrency between construction and transmission:
 * The string can be transmitted while it's being constructed.
 *
 * Unlike regular stream-based approaches, a pre-rendered structure is available before transmission
 * starts. This means a transmission that is known to exceed certain limits can be stopped before a
 * single character is transmitted.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings(&quot;PMD.ExcessivePublicCount&quot;)
public interface StringHolder extends CharSequence, HasLength, Comparable&lt;Object&gt;, Cloneable {
  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplier(Supplier&lt;?&gt; supplier) {
<span class="fc" id="L57">    return withSupplierMinimumLength(0, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, assuming a minimum
   * length of 0.
   *
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplier(IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L72">    return withSupplierMinimumLength(0, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumLength(int minLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L86">    return new SuppliedStringHolder(minLength, minLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumLength(int minLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L103">    return new SuppliedStringHolder(minLength, minLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierExpectedLength(int expectedLength, Supplier&lt;?&gt; supplier) {
<span class="fc" id="L117">    return new SuppliedStringHolder(0, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierExpectedLength(int expectedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc" id="L134">    return new SuppliedStringHolder(0, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      Supplier&lt;?&gt; supplier) {
<span class="fc" id="L150">    return new SuppliedStringHolder(minLength, expectedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying a
   * minimum of the estimated length.
   *
   * @param minLength The minimum length, must not be larger than the actual length.
   * @param expectedLength The expected length, may be larger than the actual length.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if minLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierMinimumAndExpectedLength(int minLength, int expectedLength,
      IOSupplier&lt;?&gt; supplier, IOExceptionHandler onError) {
<span class="fc" id="L168">    return new SuppliedStringHolder(minLength, expectedLength, supplier, onError);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierFixedLength(int fixedLength, Supplier&lt;?&gt; supplier) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L184">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L186">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier);</span>
  }

  /**
   * Constructs a new {@link StringHolder} with content from the given supplier, specifying the
   * length the supplied string is going to have. An {@link IllegalStateException} will be thrown
   * once a string is supplied that does not match this length.
   *
   * @param fixedLength The exact length of the string.
   * @param supplier The supplier (may throw an {@link IOException} upon {@link Supplier#get()},
   *          which is handled by the given exception handler).
   * @param onError The exception handler.
   * @return The {@link StringHolder} instance.
   * @throws IllegalStateException if fixedLength is negative.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withSupplierFixedLength(int fixedLength, IOSupplier&lt;?&gt; supplier,
      IOExceptionHandler onError) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (fixedLength == 0) {</span>
<span class="fc" id="L205">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    }
<span class="fc" id="L207">    return new FixedLengthSuppliedStringHolder(fixedLength, supplier, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplier(IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L220">    return new ReaderStringHolder(0, 0, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierMinimumLength(int minLen, IOSupplier&lt;Reader&gt; readerSupply,
      IOExceptionHandler onError) {
<span class="fc" id="L234">    return new ReaderStringHolder(minLen, minLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierExpectedLength(int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L248">    return new ReaderStringHolder(0, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a {@link ReaderStringHolder} with the given Reader source.
   *
   * @param minLen The minimum length of the content, must not be larger than the actual length.
   * @param expectedLen The expected length of the content, which is only an estimate.
   * @param readerSupply The supply of {@link Reader} instances for the content.
   * @param onError The exception handler.
   * @return The {@link ReaderStringHolder}.
   * @throws NullPointerException if supplier was {@code null}.
   */
  static StringHolder withReaderSupplierMinimumAndExpectedLength(int minLen, int expectedLen,
      IOSupplier&lt;Reader&gt; readerSupply, IOExceptionHandler onError) {
<span class="fc" id="L263">    return new ReaderStringHolder(minLen, expectedLen, readerSupply, onError);</span>
  }

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newSequence() {
<span class="fc" id="L272">    return new StringHolderSequence();</span>
  }

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newSequence(int estimatedNumberOfAppends) {
<span class="fc" id="L284">    return new StringHolderSequence(estimatedNumberOfAppends);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence() {
<span class="fc" id="L296">    return new AsyncStringHolderSequence();</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param executor The executor to use.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence(Executor executor) {
<span class="fc" id="L310">    return new AsyncStringHolderSequence(executor);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   *
   * @return The new, empty async sequence.
   */
  static StringHolderSequence newAsyncSequence(int estimatedNumberOfAppends) {
<span class="fc" id="L325">    return new AsyncStringHolderSequence(estimatedNumberOfAppends);</span>
  }

  /**
   * Constructs a new, empty async {@link StringHolderSequence}.
   *
   * {@link StringHolder}s are automatically converted upon append, with appends being run
   * asynchronously, using temporary intermediate storage, if possible/necessary.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to
   *          {@link StringHolderSequence#append(Object)}, etc.
   * @param executor The executor to use.
   *
   * @return The new, empty sequence.
   */
  static StringHolderSequence newAsyncSequence(int estimatedNumberOfAppends, Executor executor) {
<span class="fc" id="L341">    return new AsyncStringHolderSequence(estimatedNumberOfAppends, executor);</span>
  }

  /**
   * Constructs a {@link StringHolder} with the given content.
   *
   * Unless the object already is a {@link StringHolder}, or is known to be empty, its contents are
   * converted to String. {@code null} objects are converted to {@code &quot;null&quot;}, in accordance with
   * {@link String#valueOf(Object)}.
   *
   * @param obj The object.
   * @return The {@link StringHolder} instance.
   */
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  static StringHolder withContent(Object obj) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">    if (obj == null) {</span>
<span class="fc" id="L357">      return CommonStrings.NULL_STRINGHOLDER;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    } else if (obj instanceof String) {</span>
<span class="fc" id="L359">      String s = (String) obj;</span>
<span class="fc" id="L360">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L362">        return sh;</span>
      }
<span class="fc" id="L364">      return new SimpleStringHolder(s);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    } else if (obj instanceof StringHolder) {</span>
<span class="fc" id="L366">      return (StringHolder) obj;</span>
    } else {
<span class="fc bfc" id="L368" title="All 2 branches covered.">      if (obj instanceof CharSequence) {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (CharSequenceReleaseShim.isEmpty((CharSequence) obj)) {</span>
<span class="fc" id="L370">          return CommonStrings.EMPTY_STRINGHOLDER;</span>
        }
      } else {
<span class="fc" id="L373">        StringHolder sh = CommonStrings.lookup(obj);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (sh != null) {</span>
<span class="fc" id="L375">          return sh;</span>
        }
      }
<span class="fc" id="L378">      String s = String.valueOf(obj);</span>
<span class="fc" id="L379">      StringHolder sh = CommonStrings.lookup(s);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (sh != null) {</span>
<span class="fc" id="L381">        return sh;</span>
      }
<span class="fc" id="L383">      return new SimpleStringHolder(s);</span>
    }
  }

  /**
   * Constructs a {@link StringHolder} with the given content sequences, as if they had been
   * appended to a {@link StringHolderSequence}. Empty sequences are optimized.
   *
   * @param objects The objects to represent as a sequence; if {@code null}, a StringHolder of the
   *          string {@code &quot;null&quot;} is returned.
   * @return The {@link StringHolder} instance.
   * @see #withContent(Object)
   */
  static StringHolder withContent(Object... objects) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">    if (objects == null) {</span>
<span class="fc" id="L398">      return CommonStrings.NULL_STRINGHOLDER;</span>
    }
<span class="fc bfc" id="L400" title="All 3 branches covered.">    switch (objects.length) {</span>
      case 0:
<span class="fc" id="L402">        return CommonStrings.EMPTY_STRINGHOLDER;</span>
      case 1:
<span class="fc" id="L404">        return withContent(objects[0]);</span>
      default:
        // see below
    }
<span class="fc" id="L408">    StringHolderSequence seq = new StringHolderSequence(objects.length);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    for (Object obj : objects) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (((StringHolder) obj).isKnownEmpty()) {</span>
<span class="fc" id="L412">          continue;</span>
        }
<span class="fc bfc" id="L414" title="All 4 branches covered.">      } else if (obj instanceof CharSequence &amp;&amp; CharSequenceReleaseShim.isEmpty(</span>
          (CharSequence) obj)) {
<span class="fc" id="L416">        continue;</span>
      }
<span class="fc" id="L418">      seq.append(obj);</span>
    }
<span class="fc bfc" id="L420" title="All 2 branches covered.">    if (seq.numberOfAppends() == 0) {</span>
<span class="fc" id="L421">      return CommonStrings.EMPTY_STRINGHOLDER;</span>
    } else {
<span class="fc" id="L423">      return seq;</span>
    }
  }

  /**
   * Constructs a conditional wrapper around the given {@link StringHolder}; the given
   * {@code include} supplier controls whether the {@link StringHolder} is included, or effectively
   * empty.
   *
   * The conditional supplier is called at most once; the check is delayed as much as possible.
   *
   * @param wrapped The wrapped {@link StringHolder}.
   * @param includePredicate Controls the inclusion of that {@link StringHolder}; {@code false}
   *          means &quot;excluded&quot;.
   * @return the conditional {@link StringHolder}.
   */
  static StringHolder withConditionalStringHolder(StringHolder wrapped,
      Predicate&lt;StringHolder&gt; includePredicate) {
<span class="fc" id="L441">    return new ConditionalStringHolder(wrapped, includePredicate);</span>
  }

  /**
   * Constructs a wrapper around the given {@link StringHolder}, marking it as &quot;uncacheable&quot; (i.e.,
   * {@link #isCacheable()} returning {@code false}, unless {@link #isString()} is {@code true}).
   *
   * @param wrapped The wrapped {@link StringHolder}.
   * @return the uncacheable {@link StringHolder}.
   */
  static StringHolder withUncacheableStringHolder(StringHolder wrapped) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">    return wrapped.isCacheable() ? withConditionalStringHolder(wrapped, (k) -&gt; true) : wrapped;</span>
  }

  @Override
  default boolean isEmpty() {
<span class="fc bfc" id="L457" title="All 2 branches covered.">    return length() == 0;</span>
  }

  /**
   * Checks if this holder is currently backed by a plain {@link String}.
   *
   * @return {@code true} if currently backed by a plain {@link String}.
   */
  boolean isString();

  /**
   * Provides the contents of this {@link StringHolder} as a {@link Reader}.
   *
   * @return The reader.
   * @throws IOException on error.
   */
  Reader toReader() throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  void appendTo(Appendable out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}; this may
   * or may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  void appendTo(StringBuilder out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}; this may or
   * may not turn the contents of this instance into a String.
   *
   * @param out The target.
   */
  void appendTo(StringBuffer out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}; this may or may
   * not turn the contents of this instance into a String.
   *
   * @param out The target.
   * @throws IOException on error.
   */
  void appendTo(Writer out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Appendable}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  int appendToAndReturnLength(Appendable out) throws IOException;

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuilder}, and
   * returns the number of characters appended. This call may or may not turn the contents of this
   * instance into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  int appendToAndReturnLength(StringBuilder out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link StringBuffer}, and returns
   * the number of characters appended. This call may or may not turn the contents of this instance
   * into a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   */
  int appendToAndReturnLength(StringBuffer out);

  /**
   * Append the contents of this {@link StringHolder} to the given {@link Writer}, and returns the
   * number of characters appended. This call may or may not turn the contents of this instance into
   * a String.
   *
   * @param out The target.
   * @return The number of characters appended.
   * @throws IOException on error.
   */
  int appendToAndReturnLength(Writer out) throws IOException;

  /**
   * Returns the current minimum length of the expected string length in this {@link StringHolder}.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * NOTE: When using this parameter for optimizations (e.g., to speed-up equality checks), make
   * sure to also check {@link #checkError()}. When that method returns {@code true}, the minimum
   * length can actually not be guaranteed.
   *
   * @return The minimum length (but be sure to see {@link #checkError()}).
   */
  @Override
  int getMinimumLength();

  /**
   * Returns the current estimate of the length of the string in this {@link StringHolder}, which is
   * at least the {@link #getMinimumLength()} but could be substantially larger.
   *
   * This is equivalent to {@link #length()} if {@link #isString()} is {@code true}.
   *
   * @return The currently expected length.
   */
  @Override
  int getExpectedLength();

  /**
   * Updates the current estimate of the length of the string in this {@link StringHolder}.
   *
   * The value will be rounded to {@link #getMinimumLength()} if necessary.
   *
   * @param len The new expected length
   */
  void setExpectedLength(int len);

  /**
   * Returns the actual length of this instance's contents. This may trigger a conversion to
   * {@link String}.
   *
   * @return The actual length.
   */
  @Override
  int length();

  /**
   * Checks if this {@link StringHolder} is known to yield an empty {@link String}.
   *
   * @return {@code true} if known non-empty.
   */
  @Override
  boolean isKnownEmpty();

  /**
   * Returns {@code true} if the actual length is known, i.e. {@link #getMinimumLength()} {@code ==}
   * {@link #getExpectedLength()} {@code == } {@link #length()}.
   *
   * By default, this is only true if {@link #isString()} {@code == true}, but subclasses may
   * override this check. When they do, they must include a check for
   * {@code || super.isLengthKnown()}.
   *
   * Note that once a length is &lt;em&gt;known&lt;/em&gt;, it cannot change (i.e., don't override this for
   * mutable objects like {@link StringHolderSequence}).
   *
   * @return {@code true} if the length in this holder is known.
   * @see #isKnownEmpty()
   */
  @Override
  boolean isLengthKnown();

  /**
   * Checks if this {@link StringHolder} had some kind of unexpected condition.
   *
   * If so, {@link #getMinimumLength()} may be adjusted to a value smaller than its previous state.
   *
   * @return {@code true} if trouble was detected.
   */
  boolean checkError();

  /**
   * Returns the {@link StringHolderScope} associated with this {@link StringHolder}, or
   * {@code null} if no scope was associated.
   *
   * @return The scope, or {@code null}.
   */
  StringHolderScope getScope();

  /**
   * Sets the {@link StringHolderScope} associated with this {@link StringHolder}. Any previously
   * associated scope is removed from this instance and returned.
   *
   * @param newScope The new scope, or {@code null}/{@link StringHolderScope#NONE} to set &quot;no
   *          scope&quot;.
   * @return The old scope, or {@code null} if none was set before.
   */
  StringHolderScope updateScope(StringHolderScope newScope);

  /**
   * Returns something that can be used in {@link StringHolder#withContent(Object)} which then
   * yields the same output when calling {@link #toString()} on either instance.
   *
   * The returned object usually is this instance itself. However, this method may return a
   * simplified version of the content stored in this instance. For example, if the content already
   * is a string, the string is returned.
   *
   * @return The &quot;content&quot; of this instance, which could be the instance itself, or something else.
   * @see #withContent(Object)
   */
  Object asContent();

  @Override
  default int compareTo(Object o) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">    if (o instanceof StringHolder) {</span>
<span class="fc" id="L662">      return compareTo((StringHolder) o);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L664">      return compareTo((CharSequence) o);</span>
    } else {
<span class="fc" id="L666">      throw new ClassCastException(&quot;Cannot compare &quot; + o.getClass());</span>
    }
  }

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link String}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  int compareTo(CharSequence o);

  /**
   * Narrower implementation of {@link #compareTo(Object)} for {@link StringHolder}s.
   *
   * @param o The other object.
   * @return The comparison result, as defined by {@link #compareTo(Object)}.
   */
  int compareTo(StringHolder o);

  /**
   * Checks if this {@link StringHolder} is &lt;em&gt;effectively immutable&lt;/em&gt;.
   *
   * @return {@code true} if the contents aren't going to change.
   */
  boolean isEffectivelyImmutable();

  /**
   * Marks this instance as &lt;em&gt;effectively immutable&lt;/em&gt;.
   */
  void markEffectivelyImmutable();

  /**
   * Checks if this {@link StringHolder} is cacheable. A cacheable {@link StringHolder} may be
   * probed early for its contents (length, hashCode, etc.). This is usually the case, except when a
   * {@link StringHolder} is involved that was supplied via
   * {@link StringHolder#withConditionalStringHolder(StringHolder, Predicate)} or via
   * {@link #withUncacheableStringHolder(StringHolder)}, and that StringHolder is not already a
   * string or otherwise supplied, for example. By convention, it should be cacheable whenever
   * {@link #isString()} is {@code true}.
   *
   * @return {@code true} if cacheable.
   */
  default boolean isCacheable() {
<span class="fc" id="L710">    return true;</span>
  }

  /**
   * Deep-clones this {@link StringHolder}.
   *
   * @return The cloned instance.
   */
  StringHolder clone();

  /**
   * Returns the index within this string of the first occurrence of the specified
   * character/codepoint, or {@code -1} if not found.
   *
   * @param c The character/codepoint to look for.
   * @return The position, or {@code -1} if not found.
   */
  default int indexOf(int c) {
<span class="fc" id="L728">    return indexOf(c, 0);</span>
  }

  /**
   * Returns the index within this string of the first occurrence of the specified
   * character/codepoint, starting with the given character offset, or {@code -1} if not found.
   *
   * @param c The character/codepoint to look for.
   * @param start The character offset.
   * @return The position, or {@code -1} if not found.
   */
  default int indexOf(int c, int start) {
<span class="fc bfc" id="L740" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L741">      return toString().indexOf(c, start);</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">    } else if (isKnownEmpty()) {</span>
<span class="fc" id="L743">      return -1;</span>
    }

<span class="fc bfc" id="L746" title="All 2 branches covered.">    boolean isSurrogatePair = c &gt; 0xFFFF;</span>

<span class="fc" id="L748">    int i = 0;</span>
<span class="fc" id="L749">    int next = -1;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">    for (PrimitiveIterator.OfInt it = chars().skip(start).iterator(); next != -1 || it</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">        .hasNext(); i++) {</span>
      int ch;
<span class="fc bfc" id="L753" title="All 2 branches covered.">      if (next != -1) {</span>
<span class="fc" id="L754">        ch = next;</span>
<span class="fc" id="L755">        next = -1;</span>
      } else {
<span class="fc" id="L757">        ch = it.nextInt();</span>
      }
<span class="fc bfc" id="L759" title="All 6 branches covered.">      if (isSurrogatePair &amp;&amp; Character.isHighSurrogate((char) ch) &amp;&amp; it.hasNext()) {</span>
<span class="fc" id="L760">        char ch2 = (char) it.nextInt();</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (Character.isLowSurrogate(ch2)) {</span>
<span class="fc" id="L762">          ch = Character.toCodePoint((char) ch, ch2);</span>
        } else {
          // We detected an invalid UTF-8 surrogate, restart search from here
<span class="fc" id="L765">          next = ch2;</span>
        }
      }
<span class="fc bfc" id="L768" title="All 2 branches covered.">      if (ch == c) {</span>
<span class="fc" id="L769">        return i;</span>
      }
    }
<span class="fc" id="L772">    return -1;</span>
  }

  /**
   * Returns the index within this StringHolder of the first occurrence of the specified
   * CharSequence, or {@code -1} if not found.
   *
   * @param str The char sequence to look for.
   * @return The position, or {@code -1} if not found.
   */
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  default int indexOf(CharSequence str) {
<span class="fc" id="L784">    return indexOf(str, 0);</span>
  }

  /**
   * Returns the index within this StringHolder of the first occurrence of the specified
   * CharSequence, starting with the given character offset, or {@code -1} if not found.
   *
   * @param str The char sequence to look for.
   * @param start The character offset.
   * @return The position, or {@code -1} if not found.
   */
  @SuppressWarnings({&quot;PMD.CognitiveComplexity&quot;, &quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.NPathComplexity&quot;})
  default int indexOf(CharSequence str, int start) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">    if (str == this) { // NOPMD.CompareObjectsWithEquals</span>
<span class="fc bfc" id="L798" title="All 4 branches covered.">      return start == 0 || isEmpty() ? 0 : -1;</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">    } else if (CharSequenceReleaseShim.isEmpty(str)) {</span>
<span class="fc" id="L800">      return Math.min(start, length());</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">    } else if (isKnownEmpty()) {</span>
<span class="fc" id="L802">      return -1;</span>
    }

<span class="fc bfc" id="L805" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc bfc" id="L806" title="All 4 branches covered.">      if (str instanceof String || //</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">          (str instanceof StringHolder &amp;&amp; ((StringHolder) str).isString())) {</span>
<span class="fc" id="L808">        return toString().indexOf(str.toString());</span>
      }
    }

<span class="fc" id="L812">    int strLen = str.length();</span>
<span class="fc bfc" id="L813" title="All 4 branches covered.">    if (isLengthKnown() &amp;&amp; length() &lt; (strLen + start)) {</span>
<span class="fc" id="L814">      return -1;</span>
    }

<span class="fc" id="L817">    char firstChar = str.charAt(start);</span>
<span class="fc bfc" id="L818" title="All 3 branches covered.">    switch (strLen) {</span>
      case 1:
<span class="fc" id="L820">        return indexOf(firstChar);</span>
      case 2:
<span class="fc" id="L822">        char secondChar = str.charAt(start + 1);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">        if (Character.isSurrogatePair(firstChar, secondChar)) {</span>
<span class="fc" id="L824">          return indexOf(Character.toCodePoint(firstChar, secondChar), start);</span>
        }
        break;
      default:
        // continue below
        break;
    }

<span class="fc" id="L832">    int max = length() - strLen - start;</span>

<span class="fc" id="L834">    boolean found = false;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">    loop : for (int i = start; i &lt;= max; i++) {</span>
<span class="fc" id="L836">      char myChar = charAt(i);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">      if (myChar != firstChar) {</span>
        // seek ahead
<span class="fc bfc" id="L839" title="All 2 branches covered.">        while (++i &lt;= max) { // NOPMD.AvoidReassigningLoopVariables</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">          if (charAt(i) == firstChar) {</span>
<span class="fc" id="L841">            found = true;</span>
<span class="fc" id="L842">            break;</span>
          }
        }
      } else {
<span class="fc" id="L846">        found = true;</span>
      }
<span class="fc bfc" id="L848" title="All 2 branches covered.">      if (found) {</span>
<span class="fc" id="L849">        int myPos = i + 1;</span>
<span class="fc" id="L850">        int end = myPos + strLen - 1;</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">        for (int strPos = 1; myPos &lt; end; myPos++, strPos++) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">          if (charAt(myPos) != str.charAt(strPos)) {</span>
<span class="fc" id="L853">            continue loop;</span>
          }
        }
<span class="fc" id="L856">        return i;</span>
      }
    }
<span class="fc" id="L859">    return -1;</span>
  }

  /**
   * Checks if this {@link StringHolder} contains the given {@link CharSequence}.
   * 
   * @param s The char sequence to look for.
   * @return {@code true} if found (also if the sequence is empty).
   */
  default boolean contains(CharSequence s) {
<span class="fc bfc" id="L869" title="All 2 branches covered.">    return indexOf(s) &gt;= 0;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>