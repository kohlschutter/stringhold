<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringHolderSequence.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">stringhold-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">stringhold-common</a> &gt; <a href="index.source.html" class="el_package">com.kohlschutter.stringhold</a> &gt; <span class="el_source">StringHolderSequence.java</span></div><h1>StringHolderSequence.java</h1><pre class="source lang-java linenums">/*
 * stringhold
 *
 * Copyright 2022-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kohlschutter.stringhold;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;

/**
 * An {@link Appendable} sequence of strings or {@link StringHolder}s.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
public class StringHolderSequence extends AbstractStringHolder implements Appendable {
  List&lt;CharSequence&gt; sequence;

<span class="fc" id="L37">  private boolean immutable = false;</span>
<span class="fc" id="L38">  private boolean cannotUseCache = false;</span>
<span class="fc" id="L39">  private Integer cachedHashCode = null;</span>
<span class="fc" id="L40">  private Integer cachedLength = null;</span>

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   */
  StringHolderSequence() {
<span class="fc" id="L46">    this(10);</span>
<span class="fc" id="L47">  }</span>

  /**
   * Constructs a new, empty {@link StringHolderSequence}.
   *
   * @param estimatedNumberOfAppends Estimated number of calls to {@link #append(Object)}, etc.
   */
  StringHolderSequence(int estimatedNumberOfAppends) {
<span class="fc" id="L55">    super(0);</span>
<span class="fc" id="L56">    sequence = new ArrayList&lt;&gt;(estimatedNumberOfAppends);</span>
<span class="fc" id="L57">  }</span>

  /**
   * Checks if the to-be-appended {@link StringHolder} should be added as a {@link String} (with
   * conversion via {@link StringHolder#toString()}) instead of adding it directly.
   *
   * This is false by default for all objects. Subclasses may override this selectively. If all
   * objects should be converted to strings, use {@link StringOnlySequence}.
   *
   * @param sh The {@link StringHolder}.
   * @return {@code true} if it should be appended as a string.
   * @see StringOnlySequence
   */
  protected boolean needsStringConversion(StringHolder sh) {
<span class="fc" id="L71">    return false;</span>
  }

  private void checkMutable() {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (immutable) {</span>
<span class="fc" id="L76">      throw new IllegalStateException(</span>
          &quot;Cannot append -- instance is marked as effectively-immutable&quot;);
    }
<span class="fc" id="L79">  }</span>

  @Override
  public StringHolderSequence append(CharSequence csq, int start, int end) {
<span class="fc bfc" id="L83" title="All 2 branches covered.">    if (end == start) {</span>
<span class="fc" id="L84">      return this;</span>
    }

<span class="fc bfc" id="L87" title="All 2 branches covered.">    if (csq instanceof String) {</span>
<span class="fc" id="L88">      append(((String) csq).substring(start, end));</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">    } else if (csq instanceof StringBuilder) {</span>
<span class="fc" id="L90">      append(((StringBuilder) csq).substring(start, end));</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">    } else if (csq instanceof StringBuffer) {</span>
<span class="fc" id="L92">      append(((StringBuffer) csq).substring(start, end));</span>
    } else {
<span class="fc" id="L94">      append(csq.subSequence(start, end));</span>
    }
<span class="fc" id="L96">    return this;</span>
  }

  @Override
  public StringHolderSequence append(char c) {
<span class="fc" id="L101">    addSequence(String.valueOf(c));</span>
<span class="fc" id="L102">    return this;</span>
  }

  /**
   * Appends the given {@link String}, unless it is empty.
   *
   * @param s The string.
   * @return This instance.
   */
  public StringHolderSequence append(String s) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (!s.isEmpty()) {</span>
<span class="fc" id="L113">      addSequence(CommonStrings.lookupIfPossible(s));</span>
    }
<span class="fc" id="L115">    return this;</span>
  }

  private void addSequence(String s) {
<span class="fc" id="L119">    int len = s.length();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">    if (len == 0) {</span>
<span class="fc" id="L121">      return;</span>
    }

<span class="fc" id="L124">    checkMutable();</span>

<span class="fc" id="L126">    uncache();</span>
<span class="fc" id="L127">    sequence.add(s);</span>
<span class="fc" id="L128">    resizeBy(len, len);</span>
<span class="fc" id="L129">  }</span>

  /**
   * Appends the given {@link StringHolder}, unless it is known to be empty.
   *
   * As a side-effect, the scope of the given {@link StringHolder} is updated with the scope of this
   * instance.
   *
   * @param s The string.
   * @return This instance.
   */
  public StringHolderSequence append(StringHolder s) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (s.isKnownEmpty()) {</span>
<span class="fc" id="L142">      return this;</span>
<span class="fc bfc" id="L143" title="All 4 branches covered.">    } else if (s.isString() || needsStringConversion(s)) {</span>
<span class="fc" id="L144">      checkMutable();</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">      if (s.getScope() == getScope()) { // NOPMD</span>
        // don't double count
<span class="fc" id="L148">        s.updateScope(StringHolderScope.NONE);</span>
      }
<span class="fc" id="L150">      addSequence(s.toString());</span>

<span class="fc" id="L152">      return this;</span>
    }

<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (!s.isEffectivelyImmutable()) {</span>
<span class="fc" id="L156">      cannotUseCache = true;</span>
    }

<span class="fc" id="L159">    resizeBy(s.getMinimumLength(), s.getExpectedLength());</span>

<span class="fc" id="L161">    uncache();</span>
<span class="fc" id="L162">    sequence.add(s);</span>

<span class="fc" id="L164">    return this;</span>
  }

  /**
   * Appends the given {@link CharSequence}, unless it is known to be empty.
   *
   * @param s The string.
   */
  @Override
  public StringHolderSequence append(CharSequence s) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (s instanceof StringHolder) {</span>
<span class="fc" id="L175">      return append((StringHolder) s);</span>
    }
<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (!CharSequenceReleaseShim.isEmpty(s)) {</span>
<span class="fc" id="L178">      addSequence(CommonStrings.lookupIfPossible(String.valueOf(s)));</span>
    }
<span class="fc" id="L180">    return this;</span>
  }

  /**
   * Appends all given objects.
   *
   * @param objects The objects to append.
   * @return This instance.
   */
  public StringHolderSequence appendAll(Object... objects) {
<span class="fc" id="L190">    Objects.requireNonNull(objects);</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">    for (Object obj : objects) {</span>
<span class="fc" id="L193">      append(obj);</span>
    }
<span class="fc" id="L195">    return this;</span>
  }

  /**
   * Appends all given objects.
   *
   * @param objects The objects to append.
   * @return This instance.
   */
  public StringHolderSequence appendAll(Iterable&lt;Object&gt; objects) {
<span class="fc" id="L205">    Objects.requireNonNull(objects);</span>

<span class="fc bfc" id="L207" title="All 2 branches covered.">    for (Object obj : objects) {</span>
<span class="fc" id="L208">      append(obj);</span>
<span class="fc" id="L209">    }</span>
<span class="fc" id="L210">    return this;</span>
  }

  /**
   * Appends the given object, unless it is known to be empty.
   *
   * The object
   *
   * @param s The string.
   * @return This instance.
   */
  public StringHolderSequence append(Object s) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (s instanceof StringHolder) {</span>
<span class="fc" id="L223">      return append((StringHolder) s);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    } else if (s instanceof String) {</span>
<span class="fc" id="L225">      return append((String) s);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">    } else if (s instanceof CharSequence) {</span>
<span class="fc" id="L227">      return append((CharSequence) s);</span>
    } else {
<span class="fc" id="L229">      return append(String.valueOf(s));</span>
    }
  }

  @Override
  protected int appendToAndReturnLengthDefaultImpl(Appendable out) throws IOException {
<span class="fc" id="L235">    int len = 0;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    for (Object obj : sequence) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc" id="L238">        StringHolder holder = (StringHolder) obj;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (holder.isKnownEmpty()) {</span>
<span class="fc" id="L240">          continue;</span>
        }

<span class="fc" id="L243">        len += holder.appendToAndReturnLength(out);</span>
<span class="fc" id="L244">      } else {</span>
<span class="fc" id="L245">        String s = (String) obj;</span>
<span class="fc" id="L246">        len += s.length();</span>
<span class="fc" id="L247">        out.append(s);</span>
      }
<span class="fc" id="L249">    }</span>
<span class="fc" id="L250">    return len;</span>
  }

  @Override
  protected int appendToAndReturnLengthImpl(StringBuilder out) {
<span class="fc" id="L255">    out.ensureCapacity(out.length() + getMinimumLength());</span>

<span class="fc" id="L257">    int len = 0;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">    for (Object obj : sequence) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc" id="L260">        StringHolder holder = (StringHolder) obj;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (holder.isKnownEmpty()) {</span>
<span class="fc" id="L262">          continue;</span>
        }

<span class="fc" id="L265">        len += holder.appendToAndReturnLength(out);</span>
<span class="fc" id="L266">      } else {</span>
<span class="fc" id="L267">        String s = (String) obj;</span>
<span class="fc" id="L268">        len += s.length();</span>
<span class="fc" id="L269">        out.append(s);</span>
      }
<span class="fc" id="L271">    }</span>
<span class="fc" id="L272">    return len;</span>
  }

  @Override
  protected int appendToAndReturnLengthImpl(StringBuffer out) {
<span class="fc" id="L277">    out.ensureCapacity(out.length() + getMinimumLength());</span>

<span class="fc" id="L279">    int len = 0;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">    for (Object obj : sequence) {</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc" id="L282">        StringHolder holder = (StringHolder) obj;</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (holder.isKnownEmpty()) {</span>
<span class="fc" id="L284">          continue;</span>
        }

<span class="fc" id="L287">        len += holder.appendToAndReturnLength(out);</span>
<span class="fc" id="L288">      } else {</span>
<span class="fc" id="L289">        String s = (String) obj;</span>
<span class="fc" id="L290">        len += s.length();</span>
<span class="fc" id="L291">        out.append(s);</span>
      }
<span class="fc" id="L293">    }</span>
<span class="fc" id="L294">    return len;</span>
  }

  /**
   * Appends to a list that only holds Strings or StringSuppliers, excluding
   * {@link StringHolderSequence}s, whose contents are flattened to the list.
   *
   * @param flatList The list to append to.
   * @return The minimum for the estimated length.
   */
  final int appendToFlatList(List&lt;Object&gt; flatList) {
<span class="fc" id="L305">    int len = 0;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">    for (Object obj : sequence) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc" id="L308">        StringHolder holder = (StringHolder) obj;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (holder.isKnownEmpty()) {</span>
<span class="fc" id="L310">          continue;</span>
        }

<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (obj instanceof StringHolderSequence) {</span>
<span class="fc" id="L314">          len += ((StringHolderSequence) obj).appendToFlatList(flatList);</span>
        } else {
<span class="fc" id="L316">          len += holder.getMinimumLength();</span>
<span class="fc" id="L317">          flatList.add(obj);</span>
        }
<span class="fc" id="L319">      } else {</span>
<span class="fc" id="L320">        String s = (String) obj;</span>
<span class="fc" id="L321">        len += s.length();</span>
<span class="fc" id="L322">        flatList.add(s);</span>
      }
<span class="fc" id="L324">    }</span>
<span class="fc" id="L325">    return len;</span>
  }

  @Override
  protected String getString() {
<span class="fc" id="L330">    StringBuilder sb = new StringBuilder(Math.max(16, getExpectedLength()));</span>
<span class="fc" id="L331">    int len = appendToAndReturnLength(sb);</span>

<span class="fc" id="L333">    uncache();</span>

    final String s;
<span class="fc" id="L336">    sequence.clear();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">    if (len == 0) {</span>
<span class="fc" id="L338">      s = &quot;&quot;;</span>
    } else {
<span class="fc" id="L340">      s = sb.toString();</span>
<span class="fc" id="L341">      sequence.add(s);</span>
    }

<span class="fc" id="L344">    return s;</span>
  }

  @Override
  protected Reader newReader() {
<span class="fc bfc" id="L349" title="All 2 branches covered.">    if (sequence.isEmpty()) {</span>
<span class="fc" id="L350">      return new StringReader(&quot;&quot;);</span>
    }

<span class="fc" id="L353">    final List&lt;Object&gt; flatList = new ArrayList&lt;&gt;(sequence.size());</span>
<span class="fc" id="L354">    int len = appendToFlatList(flatList);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (len == 0) {</span>
<span class="fc" id="L356">      return new StringReader(&quot;&quot;);</span>
    }

<span class="fc" id="L359">    return new StringSequenceReader(flatList.iterator());</span>
  }

  private static final class StringSequenceReader extends Reader {
<span class="fc" id="L363">    private boolean closed = false;</span>

<span class="fc" id="L365">    private String currentString = null;</span>
    private int currentPos;

    private final Iterator&lt;Object&gt; flatObjectIterator;

    private StringSequenceReader(Iterator&lt;Object&gt; flatObjectIterator) {
<span class="fc" id="L371">      super();</span>
<span class="fc" id="L372">      this.flatObjectIterator = flatObjectIterator;</span>
<span class="fc" id="L373">    }</span>

    private void ensureOpen() throws IOException {
<span class="fc bfc" id="L376" title="All 2 branches covered.">      if (closed) {</span>
<span class="fc" id="L377">        throw new IOException(&quot;Stream closed&quot;);</span>
      }
<span class="fc" id="L379">    }</span>

    @Override
    public boolean ready() throws IOException {
<span class="fc" id="L383">      ensureOpen();</span>
<span class="fc" id="L384">      return true;</span>
    }

    @Override
    public void close() throws IOException {
<span class="fc" id="L389">      closed = true;</span>
<span class="fc" id="L390">    }</span>

    int ensureObject() {
<span class="fc bfc" id="L393" title="All 2 branches covered.">      if (currentString != null) {</span>
<span class="fc" id="L394">        int len = currentString.length();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (currentPos &gt;= len) {</span>
<span class="fc" id="L396">          currentString = null;</span>
<span class="fc" id="L397">          return ensureObject();</span>
        } else {
<span class="fc" id="L399">          return len;</span>
        }
      } else {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        while (flatObjectIterator.hasNext()) {</span>
<span class="fc" id="L403">          currentString = flatObjectIterator.next().toString();</span>
<span class="fc" id="L404">          currentPos = 0;</span>
<span class="fc" id="L405">          int len = currentString.length();</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">          if (len &gt; 0) {</span>
<span class="fc" id="L407">            return len;</span>
          }
<span class="fc" id="L409">        }</span>
<span class="fc" id="L410">        currentString = null;</span>
<span class="fc" id="L411">        return 0;</span>
      }
    }

    @Override
    public int read(char[] cbuf, int off, int len) throws IOException {
<span class="fc" id="L417">      int currentLen = ensureObject();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">      if (currentLen == 0) {</span>
<span class="fc" id="L419">        return -1;</span>
      }

<span class="fc" id="L422">      len = Math.min(currentLen - currentPos, Math.min(cbuf.length - off, len));</span>
<span class="fc" id="L423">      currentString.getChars(currentPos, currentPos + len, cbuf, off);</span>
<span class="fc" id="L424">      currentPos += len;</span>
<span class="fc" id="L425">      return len;</span>
    }

    @Override
    public int read() throws IOException {
<span class="fc" id="L430">      int currentLen = ensureObject();</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">      if (currentLen == 0) {</span>
<span class="fc" id="L432">        return -1;</span>
      }
<span class="fc" id="L434">      return currentString.charAt(currentPos++);</span>
    }
  }

  /**
   * Returns the number of appends (calls to {@link #append(Object)}, etc.) made to this instance so
   * far, minus the number of calls that were decided avoidable (e.g., zero-length appends).
   *
   * @return The number of appends.
   */
  public int numberOfAppends() {
<span class="fc" id="L445">    return sequence.size();</span>
  }

  /**
   * Returns a simplified version of the contents of this sequence, if possible.
   *
   * &lt;ol&gt;
   * &lt;li&gt;If the content is a string already, the string is returned.&lt;/li&gt;
   * &lt;li&gt;If there's no element stored, an empty string is returned.&lt;/li&gt;
   * &lt;li&gt;If there is only a single element stored, its content is returned as if
   * {@link #asContent()} was called on that element.&lt;/li&gt;
   * &lt;/ol&gt;
   */
  @Override
  public Object asContent() {
<span class="fc bfc" id="L460" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L461">      return toString();</span>
    }
<span class="fc bfc" id="L463" title="All 2 branches covered.">    if (sequence.isEmpty()) {</span>
<span class="fc" id="L464">      return &quot;&quot;;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">    } else if (sequence.size() == 1) {</span>
<span class="fc" id="L466">      Object obj = sequence.get(0);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">      if (obj instanceof String) {</span>
<span class="fc" id="L468">        return obj;</span>
      }
<span class="fc" id="L470">      StringHolder sc = (StringHolder) obj;</span>
<span class="fc" id="L471">      return sc.asContent();</span>
    } else {
<span class="fc" id="L473">      return this;</span>
    }
  }

  @Override
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  public char charAt(int index) {
<span class="fc" id="L480">    int offset = 0;</span>

<span class="fc bfc" id="L482" title="All 2 branches covered.">    if (index &lt; 0) {</span>
<span class="fc" id="L483">      throw new IndexOutOfBoundsException();</span>
    }

<span class="fc bfc" id="L486" title="All 2 branches covered.">    for (Object obj : sequence) {</span>
      final int len;

<span class="fc bfc" id="L489" title="All 2 branches covered.">      if (obj instanceof StringHolder) {</span>
<span class="fc" id="L490">        StringHolder sh = (StringHolder) obj;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (sh.isEmpty()) {</span>
<span class="fc" id="L492">          len = 0;</span>
        } else {
<span class="fc bfc" id="L494" title="All 2 branches covered.">          if (index == offset) {</span>
<span class="fc" id="L495">            return sh.charAt(index - offset);</span>
          }
<span class="fc" id="L497">          len = sh.length();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">          if (index &lt; offset + len) {</span>
<span class="fc" id="L499">            return sh.charAt(index - offset);</span>
          }
        }
<span class="fc" id="L502">      } else {</span>
<span class="fc" id="L503">        String s = (String) obj;</span>
<span class="fc" id="L504">        len = s.length();</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (index &lt; offset + len) {</span>
<span class="fc" id="L506">          return s.charAt(index - offset);</span>
        }
      }
<span class="fc" id="L509">      offset += len;</span>
<span class="fc" id="L510">    }</span>

<span class="fc" id="L512">    throw new IndexOutOfBoundsException();</span>
  }

  @Override
  public int hashCode() { // NOPMD.OverrideBothEqualsAndHashcode
<span class="fc bfc" id="L517" title="All 4 branches covered.">    if (cachedHashCode == null || cannotUseCache) {</span>
<span class="fc" id="L518">      cachedHashCode = updateHashCode(0);</span>
    }
<span class="fc" id="L520">    return cachedHashCode;</span>
  }

  @Override
  protected int updateHashCode(int h) {
<span class="fc bfc" id="L525" title="All 2 branches covered.">    if (isString()) {</span>
<span class="fc" id="L526">      return super.updateHashCode(h);</span>
    }

<span class="fc bfc" id="L529" title="All 2 branches covered.">    for (CharSequence obj : sequence) {</span>
<span class="fc" id="L530">      h = updateHashCode(obj, h);</span>
<span class="fc" id="L531">    }</span>

<span class="fc" id="L533">    return h;</span>
  }

  private static int updateHashCode(Object obj, int h) {
<span class="fc bfc" id="L537" title="All 2 branches covered.">    if (obj instanceof AbstractStringHolder) {</span>
<span class="fc" id="L538">      AbstractStringHolder sh = (AbstractStringHolder) obj;</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">      if (!sh.isKnownEmpty()) {</span>
<span class="fc" id="L540">        h = sh.updateHashCode(h);</span>
      }
<span class="fc" id="L542">    } else {</span>
<span class="fc" id="L543">      CharSequence s = (CharSequence) obj;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">      if (h == 0) {</span>
<span class="fc" id="L545">        return s.hashCode();</span>
      }
<span class="fc" id="L547">      int len = s.length();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">      for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L549">        h = 31 * h + s.charAt(i);</span>
      }
    }

<span class="fc" id="L553">    return h;</span>
  }

  @Override
  protected boolean checkEquals(StringHolder sh) {
<span class="fc bfc" id="L558" title="All 2 branches covered.">    if (sh instanceof StringHolderSequence) {</span>
<span class="fc" id="L559">      StringHolderSequence shs = (StringHolderSequence) sh;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">      if (sequence.equals(shs.sequence)) {</span>
<span class="fc" id="L561">        return true;</span>
      }
    }

<span class="fc" id="L565">    return super.checkEquals(sh);</span>
  }

  @Override
  protected void uncache() {
<span class="fc" id="L570">    super.uncache();</span>
<span class="fc" id="L571">    cachedHashCode = null;</span>
<span class="fc" id="L572">    cachedLength = null;</span>
<span class="fc" id="L573">  }</span>

  @Override
  protected int computeLength() {
<span class="fc" id="L577">    Integer length = cachedLength;</span>
<span class="fc bfc" id="L578" title="All 4 branches covered.">    if (length == null || cannotUseCache) {</span>
<span class="fc" id="L579">      int len = 0;</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">      for (CharSequence obj : sequence) {</span>
<span class="fc" id="L581">        len += obj.length();</span>
<span class="fc" id="L582">      }</span>
<span class="fc" id="L583">      cachedLength = length = len;</span>
    }
<span class="fc" id="L585">    return length;</span>
  }

  @Override
  public boolean isEffectivelyImmutable() {
<span class="fc" id="L590">    return immutable;</span>
  }

  @Override
  public void markEffectivelyImmutable() {
<span class="fc bfc" id="L595" title="All 2 branches covered.">    if (immutable) {</span>
<span class="fc" id="L596">      return;</span>
    }
<span class="fc bfc" id="L598" title="All 2 branches covered.">    for (Object seq : sequence) {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">      if (!(seq instanceof StringHolder)) {</span>
<span class="fc" id="L600">        continue;</span>
      }
<span class="fc" id="L602">      StringHolder sh = (StringHolder) seq;</span>
<span class="fc" id="L603">      sh.markEffectivelyImmutable();</span>
<span class="fc" id="L604">    }</span>
<span class="fc" id="L605">    immutable = true;</span>
<span class="fc" id="L606">  }</span>

  @Override
  public boolean isCacheable() {
<span class="fc bfc" id="L610" title="All 2 branches covered.">    for (Object seq : sequence) {</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (!(seq instanceof StringHolder)) {</span>
<span class="fc" id="L612">        continue;</span>
      }
<span class="fc" id="L614">      StringHolder sh = (StringHolder) seq;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">      if (!sh.isCacheable()) {</span>
<span class="fc" id="L616">        return false;</span>
      }
<span class="fc" id="L618">    }</span>
<span class="fc" id="L619">    return true;</span>
  }

  @Override
  public StringHolderSequence clone() {
<span class="fc" id="L624">    StringHolderSequence clone = (StringHolderSequence) super.clone();</span>

<span class="fc" id="L626">    List&lt;CharSequence&gt; seq = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">    for (int i = 0, n = sequence.size(); i &lt; n; i++) {</span>
<span class="fc" id="L628">      CharSequence cs = sequence.get(i);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">      if (cs instanceof StringHolder) {</span>
<span class="fc" id="L630">        cs = ((StringHolder) cs).clone();</span>
      }
<span class="fc" id="L632">      seq.add(cs);</span>
    }
<span class="fc" id="L634">    clone.sequence = seq;</span>

<span class="fc" id="L636">    return clone;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>